<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · Quantica.jl</title><link rel="canonical" href="https://pablosanjose.github.io/Quantica.jl/reference/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="Quantica.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="Quantica.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Quantica.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li class="is-active"><a class="tocitem" href>Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/pablosanjose/Quantica.jl/blob/master/docs/src/reference.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><ul><li><a href="#Quantica.Quantica"><code>Quantica.Quantica</code></a></li><li><a href="#Quantica.BoxIterator"><code>Quantica.BoxIterator</code></a></li><li><a href="#Quantica.MeshSpec"><code>Quantica.MeshSpec</code></a></li><li><a href="#Base.:&amp;-Tuple{Quantica.Hamiltonian{#s38,L,M,A,H,O} where O&lt;:Tuple{Vararg{Tuple{Vararg{Symbol,N} where N},N} where N} where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s38&lt;:Quantica.Superlattice,Quantica.Hamiltonian{#s37,L,M,A,H,O} where O&lt;:Tuple{Vararg{Tuple{Vararg{Symbol,N} where N},N} where N} where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s37&lt;:Quantica.Superlattice}"><code>Base.:&amp;</code></a></li><li><a href="#Base.:|-Tuple{Quantica.Hamiltonian{#s38,L,M,A,H,O} where O&lt;:Tuple{Vararg{Tuple{Vararg{Symbol,N} where N},N} where N} where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s38&lt;:Quantica.Superlattice,Quantica.Hamiltonian{#s37,L,M,A,H,O} where O&lt;:Tuple{Vararg{Tuple{Vararg{Symbol,N} where N},N} where N} where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s37&lt;:Quantica.Superlattice}"><code>Base.:|</code></a></li><li><a href="#Base.factorial-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Integer"><code>Base.factorial</code></a></li><li><a href="#Base.xor-Tuple{Quantica.Hamiltonian{#s38,L,M,A,H,O} where O&lt;:Tuple{Vararg{Tuple{Vararg{Symbol,N} where N},N} where N} where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s38&lt;:Quantica.Superlattice,Quantica.Hamiltonian{#s37,L,M,A,H,O} where O&lt;:Tuple{Vararg{Tuple{Vararg{Symbol,N} where N},N} where N} where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s37&lt;:Quantica.Superlattice}"><code>Base.xor</code></a></li><li><a href="#Quantica.averageKPM-Tuple{Any,Any}"><code>Quantica.averageKPM</code></a></li><li><a href="#Quantica.bands-Tuple{Quantica.Bandstructure}"><code>Quantica.bands</code></a></li><li><a href="#Quantica.bandstructure-Tuple{Quantica.Hamiltonian}"><code>Quantica.bandstructure</code></a></li><li><a href="#Quantica.bloch"><code>Quantica.bloch</code></a></li><li><a href="#Quantica.bloch!"><code>Quantica.bloch!</code></a></li><li><a href="#Quantica.bravais-Tuple{Vararg{Union{Tuple, AbstractArray{T,1} where T, AbstractArray{T,2} where T},N} where N}"><code>Quantica.bravais</code></a></li><li><a href="#Quantica.buildlift-Tuple{Quantica.MeshSpec,Union{Quantica.Hamiltonian, Quantica.ParametricHamiltonian}}"><code>Quantica.buildlift</code></a></li><li><a href="#Quantica.buildmesh-Tuple{Quantica.MeshSpec,Union{Quantica.Hamiltonian, Quantica.ParametricHamiltonian}}"><code>Quantica.buildmesh</code></a></li><li><a href="#Quantica.combine-Tuple{Vararg{Quantica.Hamiltonian,N} where N}"><code>Quantica.combine</code></a></li><li><a href="#Quantica.combine-Tuple{Vararg{Quantica.Lattice,N} where N}"><code>Quantica.combine</code></a></li><li><a href="#Quantica.densityKPM-Tuple{Any,Any}"><code>Quantica.densityKPM</code></a></li><li><a href="#Quantica.dims-Union{Tuple{Quantica.Lattice{E,L,T,B,U} where U&lt;:(Quantica.Unitcell{E,T,N} where N) where B&lt;:(Quantica.Bravais{E,L,T,EL} where EL) where T&lt;:AbstractFloat}, Tuple{L}, Tuple{E}} where L where E"><code>Quantica.dims</code></a></li><li><a href="#Quantica.dosKPM-Tuple{Any}"><code>Quantica.dosKPM</code></a></li><li><a href="#Quantica.energies-Tuple{Quantica.Spectrum}"><code>Quantica.energies</code></a></li><li><a href="#Quantica.flatten-Tuple{}"><code>Quantica.flatten</code></a></li><li><a href="#Quantica.hamiltonian-Tuple{Any,Vararg{Any,N} where N}"><code>Quantica.hamiltonian</code></a></li><li><a href="#Quantica.hopping-Tuple{Any}"><code>Quantica.hopping</code></a></li><li><a href="#Quantica.lattice-Tuple{Quantica.Sublat,Vararg{Quantica.Sublat,N} where N}"><code>Quantica.lattice</code></a></li><li><a href="#Quantica.linearmesh-Tuple"><code>Quantica.linearmesh</code></a></li><li><a href="#Quantica.marchingmesh-Union{Tuple{Vararg{Tuple,L}}, Tuple{L}} where L"><code>Quantica.marchingmesh</code></a></li><li><a href="#Quantica.momentaKPM"><code>Quantica.momentaKPM</code></a></li><li><a href="#Quantica.offdiagonal-Tuple{Quantica.TightbindingModel,Any,Any}"><code>Quantica.offdiagonal</code></a></li><li><a href="#Quantica.onsite-Tuple{Any}"><code>Quantica.onsite</code></a></li><li><a href="#Quantica.optimize!-Union{Tuple{Quantica.Hamiltonian{#s35,L,M,A,H,O} where O&lt;:Tuple{Vararg{Tuple{Vararg{Symbol,N} where N},N} where N} where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where #s35&lt;:Quantica.Lattice}, Tuple{A}, Tuple{M}, Tuple{L}} where A&lt;:SparseMatrixCSC where M where L"><code>Quantica.optimize!</code></a></li><li><a href="#Quantica.parameters-Tuple{Vararg{Quantica.ElementModifier,N} where N}"><code>Quantica.parameters</code></a></li><li><a href="#Quantica.parameters-Tuple{Quantica.ParametricHamiltonian}"><code>Quantica.parameters</code></a></li><li><a href="#Quantica.parametric-Tuple{Quantica.Hamiltonian,Vararg{Quantica.ElementModifier,N} where N}"><code>Quantica.parametric</code></a></li><li><a href="#Quantica.permutations-Tuple{Any}"><code>Quantica.permutations</code></a></li><li><a href="#Quantica.permutations-Tuple{Any,Integer}"><code>Quantica.permutations</code></a></li><li><a href="#Quantica.similarmatrix-Union{Tuple{Any}, Tuple{A´}, Tuple{Any,Type{A´}}} where A´&lt;:(AbstractArray{T,2} where T)"><code>Quantica.similarmatrix</code></a></li><li><a href="#Quantica.sites-Tuple{Quantica.AbstractLattice}"><code>Quantica.sites</code></a></li><li><a href="#Quantica.spectrum-Tuple{Any}"><code>Quantica.spectrum</code></a></li><li><a href="#Quantica.states-Tuple{Quantica.Bandstructure,Any}"><code>Quantica.states</code></a></li><li><a href="#Quantica.states-Tuple{Quantica.Spectrum}"><code>Quantica.states</code></a></li><li><a href="#Quantica.sublat-Tuple{Array{#s36,1} where #s36&lt;:(StaticArrays.SArray{Tuple{S},T,1,S} where T where S)}"><code>Quantica.sublat</code></a></li><li><a href="#Quantica.supercell-Tuple{Vararg{Union{Integer, Tuple, StaticArrays.SArray{Tuple{S},T,1,S} where T where S, StaticArrays.SArray{Tuple{S1,S2},T,2,L} where L where T where S2 where S1},N} where N}"><code>Quantica.supercell</code></a></li><li><a href="#Quantica.transform!-Tuple{Any,Quantica.Bandstructure}"><code>Quantica.transform!</code></a></li><li><a href="#Quantica.transform!-Tuple{Function,Quantica.Lattice}"><code>Quantica.transform!</code></a></li><li><a href="#Quantica.transform!-Tuple{Any,Quantica.Spectrum}"><code>Quantica.transform!</code></a></li><li><a href="#Quantica.transform!-Tuple{Any,Quantica.Hamiltonian}"><code>Quantica.transform!</code></a></li><li><a href="#Quantica.unitcell-Tuple{Vararg{Union{Integer, Tuple, StaticArrays.SArray{Tuple{S},T,1,S} where T where S, StaticArrays.SArray{Tuple{S1,S2},T,2,L} where L where T where S2 where S1},N} where N}"><code>Quantica.unitcell</code></a></li><li><a href="#Quantica.vertices-Tuple{Quantica.Bandstructure,Any}"><code>Quantica.vertices</code></a></li><li><a href="#Quantica.wrap-Union{Tuple{L}, Tuple{Quantica.Hamiltonian{#s36,L,M,A,H,O} where O&lt;:Tuple{Vararg{Tuple{Vararg{Symbol,N} where N},N} where N} where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where #s36&lt;:Quantica.Lattice,Any}} where L"><code>Quantica.wrap</code></a></li><li><a href="#Quantica.@hopping!-Tuple{Any,Any}"><code>Quantica.@hopping!</code></a></li><li><a href="#Quantica.@onsite!-Tuple{Any,Any}"><code>Quantica.@onsite!</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="Quantica.Quantica" href="#Quantica.Quantica"><code>Quantica.Quantica</code></a> — <span class="docstring-category">Module</span></header><section><div><p><strong>Quantica.jl</strong></p><p><a href="https://pablosanjose.github.io/Quantica.jl/stable"><img src="https://img.shields.io/badge/docs-stable-blue.svg" alt="Stable"/></a> <a href="https://pablosanjose.github.io/Quantica.jl/dev"><img src="https://img.shields.io/badge/docs-dev-blue.svg" alt="Dev"/></a> <a href="https://github.com/pablosanjose/Quantica.jl/actions"><img src="https://github.com/pablosanjose/Quantica.jl/workflows/CI/badge.svg" alt="Build Status"/></a> <a href="https://codecov.io/gh/pablosanjose/Quantica.jl"><img src="https://codecov.io/gh/pablosanjose/Quantica.jl/branch/master/graph/badge.svg" alt="Coverage"/></a> <a href="https://github.com/pablosanjose/Quantica.jl"><img src="https://img.shields.io/github/commits-since/pablosanjose/Quantica.jl/latest?include_prereleases&amp;sort=semver&amp;style=social" alt="GitHub commits since last release"/></a></p><p>The Quantica.jl package provides an expressive API to build arbitrary quantum systems on a discrete lattice, and to compute a number of their properties.</p><p><strong>Some current features</strong></p><ul><li>Build Hamiltonians on discrete lattices of arbitrary dimensions, using tight-binding models with arbitrary number of orbitals</li><li>Compute band structures of periodic systems and extract individual bands by interpolation</li><li>Compute electronic structures and expectation values using Kernel Polynomial methods</li></ul><p><strong>Exported API</strong></p><ul><li><code>lattice</code>, <code>sublat</code>, <code>bravais</code>: build lattices</li><li><code>dims</code>, <code>sites</code>: inspect lattices</li><li><code>hopping</code>, <code>onsite</code>: build tightbinding models</li><li><code>hamiltonian</code>: build a Hamiltonian from tightbinding model and a lattice</li><li><code>parametric</code>, <code>@onsite!</code>, <code>@hopping!</code>, <code>parameters</code>: build a parametric Hamiltonian</li><li><code>supercell</code>, <code>unitcell</code>, <code>flatten</code>, <code>wrap</code>, <code>transform!</code>, <code>combine</code>: build derived lattices or Hamiltonians</li><li><code>marchingmesh</code>, <code>linearmesh</code>: define a specification to build a bandstructure discretization mesh</li><li><code>bandstructure</code>, <code>spectrum</code>: compute the generalized bandstructure of a Hamiltonian or a ParametricHamiltonian</li><li><code>bands</code>, <code>energies</code>, <code>states</code>: inspect spectrum and bandstructure objects</li><li><code>momentaKPM</code>, <code>dosKPM</code>, <code>averageKPM</code>, <code>densityKPM</code>, <code>bandrangeKPM</code>: Kernel Polynomial Method</li></ul><p>Some of this functionality require loading one or more third-party packages, which include the following:</p><ul><li>KPM: <code>FFTW</code>, <code>ArnoldiMethod</code></li><li>Bandstructures: <code>Arpack</code>, <code>ArnoldiMethod</code>, <code>KrylovKit</code></li></ul><p>The user is told when this is needed. We do this to reduce dependencies and launch time with packages whose functionality is not essential for the use of Quantica.jl</p><p>Other functions become available after loading specific third-party packages:</p><ul><li>Makie: enables <code>plot(::Hamiltonian)</code> and <code>plot(::Bandstructure)</code> (for 1D and 2D bandstructures)</li><li>VegaLite: enables <code>vlplot(::Hamiltonian)</code> and <code>vlplot(::Bandstructure)</code> (for 1D bandstructures)</li></ul><p><strong>Funding</strong></p><pre><code class="language-none">This work has been partly funded by the Spanish Ministry of Economy and Competitiveness under Grant Nos. FIS2015-65706-P, PCI2018-093026, and the CSIC Intramural Project 201760I086.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/Quantica.jl#LL4-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.BoxIterator" href="#Quantica.BoxIterator"><code>Quantica.BoxIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BoxIterator(seed::SVector{N,Int}; maxiterations = missing)</code></pre><p>Cartesian iterator <code>iter</code> over <code>SVector{N,Int}</code>s (<code>cell</code>s) that starts at <code>seed</code> and grows outwards in the form of a box of increasing sides (not necesarily equal) until it encompasses a certain N-dimensional region. To signal that a cell is in the desired region the user calls <code>acceptcell!(iter, cell)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/iterators.jl#LL5-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.MeshSpec" href="#Quantica.MeshSpec"><code>Quantica.MeshSpec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MeshSpec</code></pre><p>Parent type of mesh specifications, which are currently <code>MarchingMeshSpec</code> (constructed with <code>marchingmesh</code>) and <code>LinearMeshSpec</code> (constructed with <code>linearmesh</code>).</p><p><strong>See also</strong></p><pre><code class="language-none">`marchingmesh`, `linearmesh`, `buildmesh`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/mesh.jl#LL117-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:&amp;-Tuple{Quantica.Hamiltonian{#s38,L,M,A,H,O} where O&lt;:Tuple{Vararg{Tuple{Vararg{Symbol,N} where N},N} where N} where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s38&lt;:Quantica.Superlattice,Quantica.Hamiltonian{#s37,L,M,A,H,O} where O&lt;:Tuple{Vararg{Tuple{Vararg{Symbol,N} where N},N} where N} where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s37&lt;:Quantica.Superlattice}" href="#Base.:&amp;-Tuple{Quantica.Hamiltonian{#s38,L,M,A,H,O} where O&lt;:Tuple{Vararg{Tuple{Vararg{Symbol,N} where N},N} where N} where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s38&lt;:Quantica.Superlattice,Quantica.Hamiltonian{#s37,L,M,A,H,O} where O&lt;:Tuple{Vararg{Tuple{Vararg{Symbol,N} where N},N} where N} where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s37&lt;:Quantica.Superlattice}"><code>Base.:&amp;</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">&amp;(h1::Hamiltonian{&lt;:Superlattice}, h2::Hamiltonian{&lt;:Superlattice})</code></pre><p>Construct a new <code>Hamiltonian{&lt;:Superlattice}</code> using an <code>and</code> boolean mask, i.e. with a supercell that contains cells that are both in the supercell of <code>h1</code> and <code>h2</code></p><pre><code class="language-none">&amp;(s1::Superlattice, s2::Superlattice}</code></pre><p>Equivalent of the above for <code>Superlattice</code>s</p><p><strong>See also:</strong></p><pre><code class="language-none">`|`, `xor`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/hamiltonian.jl#LL398-L410">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:|-Tuple{Quantica.Hamiltonian{#s38,L,M,A,H,O} where O&lt;:Tuple{Vararg{Tuple{Vararg{Symbol,N} where N},N} where N} where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s38&lt;:Quantica.Superlattice,Quantica.Hamiltonian{#s37,L,M,A,H,O} where O&lt;:Tuple{Vararg{Tuple{Vararg{Symbol,N} where N},N} where N} where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s37&lt;:Quantica.Superlattice}" href="#Base.:|-Tuple{Quantica.Hamiltonian{#s38,L,M,A,H,O} where O&lt;:Tuple{Vararg{Tuple{Vararg{Symbol,N} where N},N} where N} where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s38&lt;:Quantica.Superlattice,Quantica.Hamiltonian{#s37,L,M,A,H,O} where O&lt;:Tuple{Vararg{Tuple{Vararg{Symbol,N} where N},N} where N} where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s37&lt;:Quantica.Superlattice}"><code>Base.:|</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">|(h1::Hamiltonian{&lt;:Superlattice}, h2::Hamiltonian{&lt;:Superlattice})</code></pre><p>Construct a new <code>Hamiltonian{&lt;:Superlattice}</code> using an <code>or</code> boolean mask, i.e. with a supercell that contains cells that are either in the supercell of <code>h1</code> or <code>h2</code></p><pre><code class="language-none">|(s1::Superlattice, s2::Superlattice}</code></pre><p>Equivalent of the above for <code>Superlattice</code>s</p><p><strong>See also:</strong></p><pre><code class="language-none">`&amp;`, `xor`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/hamiltonian.jl#LL414-L426">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.factorial-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Integer" href="#Base.factorial-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Integer"><code>Base.factorial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">factorial(n, k)</code></pre><p>Compute <span>$n!/k!$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/tools.jl#LL289-L293">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.xor-Tuple{Quantica.Hamiltonian{#s38,L,M,A,H,O} where O&lt;:Tuple{Vararg{Tuple{Vararg{Symbol,N} where N},N} where N} where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s38&lt;:Quantica.Superlattice,Quantica.Hamiltonian{#s37,L,M,A,H,O} where O&lt;:Tuple{Vararg{Tuple{Vararg{Symbol,N} where N},N} where N} where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s37&lt;:Quantica.Superlattice}" href="#Base.xor-Tuple{Quantica.Hamiltonian{#s38,L,M,A,H,O} where O&lt;:Tuple{Vararg{Tuple{Vararg{Symbol,N} where N},N} where N} where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s38&lt;:Quantica.Superlattice,Quantica.Hamiltonian{#s37,L,M,A,H,O} where O&lt;:Tuple{Vararg{Tuple{Vararg{Symbol,N} where N},N} where N} where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where L where #s37&lt;:Quantica.Superlattice}"><code>Base.xor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">xor(h1::Hamiltonian{&lt;:Superlattice}, h2::Hamiltonian{&lt;:Superlattice})</code></pre><p>Construct a new <code>Hamiltonian{&lt;:Superlattice}</code> using a <code>xor</code> boolean mask, i.e. with a supercell that contains cells that are either in the supercell of <code>h1</code> or <code>h2</code> but not in both</p><pre><code class="language-none">xor(s1::Superlattice, s2::Superlattice}</code></pre><p>Equivalent of the above for <code>Superlattice</code>s</p><p><strong>See also:</strong></p><pre><code class="language-none">`&amp;`, `|`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/hamiltonian.jl#LL430-L443">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.averageKPM-Tuple{Any,Any}" href="#Quantica.averageKPM-Tuple{Any,Any}"><code>Quantica.averageKPM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">averageKPM(h::AbstractMatrix, A; kBT = 0, Ef = 0, kw...)</code></pre><p>Compute, using the Kernel Polynomial Method (KPM), the thermal expectation value <code>&lt;A&gt; = Σ_k f(E_k) &lt;k|A|k&gt; =  ∫dE f(E) Tr [A δ(E-H)] = Tr [A f(H)]</code> for a given hermitian operator <code>A</code> and a hamiltonian <code>h</code> (see <code>momentaKPM</code> and its options <code>kw</code> for further details). <code>f(E)</code> is the Fermi-Dirac distribution function, <code>kBT</code> is the temperature in energy units and <code>Ef</code> the Fermi energy.</p><pre><code class="language-none">averageKPM(μ::MomentaKPM, A; kBT = 0, Ef = 0)</code></pre><p>Same as above with the KPM momenta as input (see <code>momentaKPM</code>).</p><pre><code class="language-none">averageKPM(h::Hamiltonian, A::Hamiltonian; kw...)</code></pre><p>Equivalent to <code>averageKPM(bloch(h), bloch(A); kw...)</code> for finite Hamiltonians (zero dimensional).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/KPM.jl#LL312-L329">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.bands-Tuple{Quantica.Bandstructure}" href="#Quantica.bands-Tuple{Quantica.Bandstructure}"><code>Quantica.bands</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bands(bs::Bandstructure)</code></pre><p>Return a vector of all the <code>Band</code>s in <code>bs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/bandstructure.jl#LL96-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.bandstructure-Tuple{Quantica.Hamiltonian}" href="#Quantica.bandstructure-Tuple{Quantica.Hamiltonian}"><code>Quantica.bandstructure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bandstructure(h::Hamiltonian; points = 13, kw...)</code></pre><p>Compute the bandstructure of <code>h</code> on a mesh over <code>h</code>&#39;s full Brillouin zone, with <code>points</code> points along each axis, spanning the interval [-π,π] along each reciprocal axis.</p><pre><code class="language-none">bandstructure(h::Hamiltonian, spec::MeshSpec; lift = missing, kw...)</code></pre><p>Call <code>bandstructure(h, mesh; lift = lift, kw...)</code> with <code>mesh = buildmesh(spec, h)</code> and <code>lift = buildlift(spec, h)</code> if not provided. See <code>MeshSpec</code> for available mesh specs. If the <code>lift = missing</code> and the dimensions of the mesh do not match the Hamiltonian&#39;s, a <code>lift</code> function is used that lifts the mesh onto the dimensions <code>h</code> by appending vertex coordinates with zeros.</p><pre><code class="language-none">bandstructure(h::Hamiltonian, mesh::Mesh; lift = missing, kw...)</code></pre><p>Compute the bandstructure <code>bandstructure(h, mesh; kw...)</code> of Bloch Hamiltonian <code>bloch(h, ϕ)</code>, with <code>ϕ = v</code> taken on each vertex <code>v</code> of <code>mesh</code> (or <code>ϕ = lift(v...)</code> if a <code>lift</code> function is provided).</p><pre><code class="language-none">bandstructure(ph::ParametricHamiltonian, ...; kw...)</code></pre><p>Compute the bandstructure of a <code>ph</code> with <code>i</code> parameters (see <code>parameters(ph)</code>), where <code>mesh</code> is interpreted as a discretization of parameter space ⊗ Brillouin zone, so that each vertex reads <code>v = (p₁,..., pᵢ, ϕ₁,..., ϕⱼ)</code>, with <code>p</code> the values assigned to <code>parameters(ph)</code> and <code>ϕᵢ</code> the Bloch phases.</p><pre><code class="language-none">bandstructure(matrixf::Function, mesh::Mesh; kw...)</code></pre><p>Compute the bandstructure of the Hamiltonian matrix <code>m = matrixf(ϕ)</code>, with <code>ϕ</code> evaluated on the vertices <code>v</code> of the <code>mesh</code>. Note that <code>ϕ</code> in <code>matrixf(ϕ)</code> is an unsplatted container. Hence, i.e. <code>matrixf(x) = ...</code> or <code>matrixf(x, y) = ...</code> will not work, use <code>matrixf((x,)) = ...</code> or <code>matrixf((x, y)) = ...</code> instead.</p><p><strong>Options</strong></p><p>The default options are</p><pre><code class="language-none">(lift = missing, minprojection = 0.5, method = defaultmethod(h), transform = missing)</code></pre><p><code>lift</code>: when not <code>missing</code>, <code>lift</code> is a function <code>lift = (vs...) -&gt; ϕ</code>, where <code>vs</code> are the coordinates of a mesh vertex and <code>ϕ</code> are Bloch phases if sampling a <code>h::Hamiltonian</code>, or <code>(paramsⱼ..., ϕᵢ...)</code> if sampling a <code>ph::ParametricHamiltonian</code>, and <code>params</code> are values for <code>parameters(ph)</code>. It represents a mapping from a mesh and a Brillouin/parameter space. This allows to compute a bandstructure along a cut in the Brillouin zone/parameter space, see below for examples.</p><p><code>minprojection</code>: determines the minimum projection between eigenstates to connect them into a common subband.</p><p><code>method</code>: it is chosen automatically if unspecified, and can be one of the following</p><pre><code class="language-none">method                     diagonalization function
--------------------------------------------------------------
LinearAlgebraPackage()     LinearAlgebra.eigen!
ArpackPackage()            Arpack.eigs (must be `using Arpack`)</code></pre><p>Options passed to the <code>method</code> will be forwarded to the diagonalization function. For example, <code>method = ArpackPackage(nev = 8, sigma = 1im)</code> will use <code>Arpack.eigs(matrix; nev = 8, sigma = 1im)</code> to compute the bandstructure.</p><p><code>transform</code>: the option <code>transform = ε -&gt; f(ε)</code> allows to transform eigenvalues by <code>f</code> in the returned bandstructure (useful for performing shifts or other postprocessing).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; h = LatticePresets.honeycomb() |&gt; hamiltonian(hopping(-1, range = 1/√3)) |&gt; unitcell(3);

julia&gt; bandstructure(h; points = 25, method = LinearAlgebraPackage())
Bandstructure{2}: collection of 2D bands
  Bands        : 8
  Element type : scalar (Complex{Float64})
  Mesh{2}: mesh of a 2-dimensional manifold
    Vertices   : 625
    Edges      : 1776

julia&gt; bandstructure(h, linearmesh(:Γ, :X, :Y, :Γ))
Bandstructure{1}: collection of 1D bands
  Bands        : 17
  Element type : scalar (Complex{Float64})
  Mesh{1}: mesh of a 1-dimensional manifold
    Vertices   : 37
    Edges      : 36

julia&gt; bandstructure(h, marchingmesh((0, 2π); points = 25); lift = φ -&gt; (φ, 0))
       # Equivalent to bandstructure(h, linearmesh(:Γ, :X; points = 11))
Bandstructure{1}: collection of 1D bands
  Bands        : 18
  Element type : scalar (Complex{Float64})
  Mesh{1}: mesh of a 1-dimensional manifold
    Vertices   : 25
    Edges      : 24</code></pre><p><strong>See also</strong></p><pre><code class="language-none">`marchingmesh`, `linearmesh`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/bandstructure.jl#LL141-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.bloch" href="#Quantica.bloch"><code>Quantica.bloch</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bloch(h::Hamiltonian{&lt;:Lattice}, ϕs)</code></pre><p>Build the Bloch Hamiltonian matrix of <code>h</code>, for Bloch phases <code>ϕs = (ϕ₁, ϕ₂,...)</code> (or an <code>SVector(ϕs...)</code>). In terms of Bloch wavevector <code>k</code>, <code>ϕs = k * bravais(h)</code>, it is defined as <code>H(ϕs) = ∑exp(-im * ϕs&#39; * dn) h_dn</code> where <code>h_dn</code> are Bloch harmonics connecting unit cells at a distance <code>dR = bravais(h) * dn</code>.</p><pre><code class="language-none">bloch(h::Hamiltonian{&lt;:Lattice})</code></pre><p>Build the intra-cell Hamiltonian matrix of <code>h</code>, without adding any Bloch harmonics.</p><pre><code class="language-none">bloch(h::Hamiltonian{&lt;:Lattice}, ϕs, axis::Int)</code></pre><p>A nonzero <code>axis</code> produces the derivative of the Bloch matrix respect to <code>ϕs[axis]</code> (i.e. the velocity operator along this axis), <code>∂H(ϕs) = ∑ -im * dn[axis] * exp(-im * ϕs&#39; * dn) h_dn</code></p><pre><code class="language-none">bloch(matrix, h::Hamiltonian{&lt;:Lattice}, ϕs::NTuple{L,Real}, dnfunc::Function)</code></pre><p>Generalization that applies a prefactor <code>dnfunc(dn) * exp(im * ϕs&#39; * dn)</code> to the <code>dn</code> harmonic.</p><pre><code class="language-none">bloch(ph::ParametricHamiltonian, pϕs, [axis])</code></pre><p>Same as above, but with <code>pϕs = (p₁,...,pᵢ, ϕ₁, ..., ϕⱼ)</code>, with <code>p</code> values for <code>parameters(ph)</code> and <code>ϕ</code> Bloch phases.</p><pre><code class="language-none">h |&gt; bloch(ϕs, ...)</code></pre><p>Functional forms of <code>bloch</code>, equivalent to <code>bloch(h, ϕs, ...)</code></p><p><strong>Notes</strong></p><p><code>bloch</code> allocates a new matrix on each call. For a non-allocating version of <code>bloch</code>, see <code>bloch!</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; h = LatticePresets.honeycomb() |&gt; hamiltonian(onsite(1) + hopping(2)) |&gt; bloch((0, 0))
2×2 SparseMatrixCSC{Complex{Float64},Int64} with 4 stored entries:
  [1, 1]  =  13.0+0.0im
  [2, 1]  =  6.0+0.0im
  [1, 2]  =  6.0+0.0im
  [2, 2]  =  13.0+0.0im</code></pre><p><strong>See also:</strong></p><pre><code class="language-none">`bloch!`, `optimize!`, `similarmatrix`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/hamiltonian.jl#LL918-L967">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.bloch!" href="#Quantica.bloch!"><code>Quantica.bloch!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bloch!(matrix, h::Hamiltonian, ϕs, [axis])</code></pre><p>In-place version of <code>bloch</code>. Overwrite <code>matrix</code> with the Bloch Hamiltonian matrix of <code>h</code> for the specified Bloch phases <code>ϕs = (ϕ₁,ϕ₂,...)</code> (see <code>bloch</code> for definition and API).  A conventient way to obtain a <code>matrix</code> is to use <code>similarmatrix(h,...)</code>, which will return an <code>AbstractMatrix</code> of the same type as the Hamiltonian&#39;s. Note, however, that matrix need not be of the same type (e.g. it can be dense with <code>Number</code> eltype for a sparse <code>h</code> with <code>SMatrix</code> block eltype).</p><pre><code class="language-none">bloch!(matrix, ph::ParametricHamiltonian, pϕs, [axis])</code></pre><p>Same as above, but with <code>pϕs = (p₁,...,pᵢ, ϕ₁, ..., ϕⱼ)</code>, with <code>p</code> values for <code>parameters(ph)</code> and <code>ϕ</code> Bloch phases.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; h = LatticePresets.honeycomb() |&gt; hamiltonian(hopping(2I), orbitals = (Val(2), Val(1)));

julia&gt; bloch!(similarmatrix(h), h, (0, 0))
2×2 SparseMatrixCSC{StaticArrays.SArray{Tuple{2,2},Complex{Float64},2,4},Int64} with 4 stored entries:
  [1, 1]  =  [12.0+0.0im 0.0+0.0im; 0.0+0.0im 12.0+0.0im]
  [2, 1]  =  [6.0+0.0im 0.0+0.0im; 0.0+0.0im 0.0+0.0im]
  [1, 2]  =  [6.0+0.0im 0.0+0.0im; 0.0+0.0im 0.0+0.0im]
  [2, 2]  =  [12.0+0.0im 0.0+0.0im; 0.0+0.0im 0.0+0.0im]

julia&gt; bloch!(similarmatrix(h, AbstractMatrix{ComplexF64}), h, (0, 0))
3×3 SparseMatrixCSC{Complex{Float64},Int64} with 9 stored entries:
  [1, 1]  =  12.0+0.0im
  [2, 1]  =  0.0+0.0im
  [3, 1]  =  6.0+0.0im
  [1, 2]  =  0.0+0.0im
  [2, 2]  =  12.0+0.0im
  [3, 2]  =  0.0+0.0im
  [1, 3]  =  6.0+0.0im
  [2, 3]  =  0.0+0.0im
  [3, 3]  =  12.0+0.0im

julia&gt; ph = parametric(h, @hopping!((t; α) -&gt; α * t));

julia&gt; bloch!(similarmatrix(ph, AbstractMatrix{ComplexF64}), ph, (2, 0, 0))
3×3 SparseMatrixCSC{Complex{Float64},Int64} with 9 stored entries:
  [1, 1]  =  24.0+0.0im
  [2, 1]  =  0.0+0.0im
  [3, 1]  =  12.0+0.0im
  [1, 2]  =  0.0+0.0im
  [2, 2]  =  24.0+0.0im
  [3, 2]  =  0.0+0.0im
  [1, 3]  =  12.0+0.0im
  [2, 3]  =  0.0+0.0im
  [3, 3]  =  24.0+0.0im</code></pre><p><strong>See also:</strong></p><pre><code class="language-none">`bloch`, `optimize!`, `similarmatrix`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/hamiltonian.jl#LL971-L1027">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.bravais-Tuple{Vararg{Union{Tuple, AbstractArray{T,1} where T, AbstractArray{T,2} where T},N} where N}" href="#Quantica.bravais-Tuple{Vararg{Union{Tuple, AbstractArray{T,1} where T, AbstractArray{T,2} where T},N} where N}"><code>Quantica.bravais</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bravais(vecs...; semibounded = false)
bravais(matrix; semibounded = false)</code></pre><p>Create a <code>Bravais{E,L}</code> that adds <code>L</code> Bravais vectors <code>vecs</code> in <code>E</code> dimensional space, alternatively given as the columns of matrix <code>mat</code>. For higher instantiation efficiency enter <code>vecs</code> as <code>Tuple</code>s or <code>SVector</code>s and <code>mat</code> as <code>SMatrix</code>.</p><p>To create semibounded lattices along some or all Bravais vectors, use <code>semibounded</code>. A <code>semibounded = true</code> makes all axes semibounded. A <code>semibounded = (axes::Int...)</code> indicates the indices of axes to be made semibounded. A tuple of Booleans, one per Bravais axes, <code>semibounded = issemi::NTuple{L,Bool}</code> is also allowed. Note that semibounded lattices always extend toward positive multiples of Bravais vectors. To invert the direction, invert the vectors.</p><p>We can scale a <code>b::Bravais</code> simply by multiplying it with a factor <code>a</code>, like <code>a * b</code>.</p><pre><code class="language-none">bravais(lat::Lattice)
bravais(h::Hamiltonian)</code></pre><p>Obtain the Bravais matrix of lattice <code>lat</code> or Hamiltonian <code>h</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; bravais((1.0, 2), (3, 4))
Bravais{2,2,Float64} : set of 2 Bravais vectors in 2D space.
  Vectors     : ((1.0, 2.0), (3.0, 4.0))
  Matrix      : [1.0 3.0; 2.0 4.0],
  Semibounded : none</code></pre><p><strong>See also:</strong></p><pre><code class="language-none">`semibounded`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/lattice.jl#LL68-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.buildlift-Tuple{Quantica.MeshSpec,Union{Quantica.Hamiltonian, Quantica.ParametricHamiltonian}}" href="#Quantica.buildlift-Tuple{Quantica.MeshSpec,Union{Quantica.Hamiltonian, Quantica.ParametricHamiltonian}}"><code>Quantica.buildlift</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">buildlift(s::MeshSpec{L}, h::Union{Hamiltonian,ParametricHamiltonian})</code></pre><p>Build a lift function that maps a <code>Mesh</code> built with <code>buildmesh(s, h)</code> to the Brillouin/parameter space of <code>h</code> (see <code>bandstructure</code> for details).</p><p><strong>See also</strong></p><pre><code class="language-none">`buildmesh`, `marchingmesh`, `linearmesh`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/mesh.jl#LL131-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.buildmesh-Tuple{Quantica.MeshSpec,Union{Quantica.Hamiltonian, Quantica.ParametricHamiltonian}}" href="#Quantica.buildmesh-Tuple{Quantica.MeshSpec,Union{Quantica.Hamiltonian, Quantica.ParametricHamiltonian}}"><code>Quantica.buildmesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">buildmesh(s::MeshSpec, h::Union{Hamiltonian,ParametricHamiltonian})</code></pre><p>Build a <code>Mesh</code> from the spec <code>s</code>, using properties of <code>h</code> as needed. The use of <code>h</code> depends on the spec. For a <code>LinearMeshSpec</code> with <code>samelength = false</code>, the Bravais matrix of <code>h</code> is needed to work out the length of each mesh segment in the Brillouin zone, while for other specs such as <code>MarchingMeshSpec</code>, <code>h</code> is not needed and may be omitted (see example).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; buildmesh(marchingmesh((-π, π), (0, 2π), points = 10))
Mesh{2}: mesh of a 2-dimensional manifold
  Vertices   : 100
  Edges      : 261</code></pre><p><strong>See also</strong></p><pre><code class="language-none">`buildlift`, `marchingmesh`, `linearmesh`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/mesh.jl#LL143-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.combine-Tuple{Vararg{Quantica.Hamiltonian,N} where N}" href="#Quantica.combine-Tuple{Vararg{Quantica.Hamiltonian,N} where N}"><code>Quantica.combine</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">combine(hams::Hamiltonian...; coupling = missing)</code></pre><p>Build a new Hamiltonian <code>h</code> that combines all <code>hams</code> as diagonal blocks, and applies <code>coupling::Model</code>, if provided, to build the off-diagonal couplings. Note that the diagonal blocks are not modified by the coupling model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/hamiltonian.jl#LL798-L804">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.combine-Tuple{Vararg{Quantica.Lattice,N} where N}" href="#Quantica.combine-Tuple{Vararg{Quantica.Lattice,N} where N}"><code>Quantica.combine</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">combine(lats::Lattice...)</code></pre><p>If all <code>lats</code> have compatible Bravais vectors, combine them into a single lattice. Sublattice names are renamed to be unique if necessary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/lattice.jl#LL529-L534">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.densityKPM-Tuple{Any,Any}" href="#Quantica.densityKPM-Tuple{Any,Any}"><code>Quantica.densityKPM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">densityKPM(h::AbstractMatrix, A; resolution = 2, kw...)</code></pre><p>Compute, using the Kernel Polynomial Method (KPM), the local spectral density of an operator <code>A</code> <code>ρ_A(ϵ) = ⟨ket|A δ(ϵ-h)|ket⟩/⟨ket|ket⟩</code> for a given <code>ket::AbstractVector</code> and hamiltonian <code>h</code>, or the global spectral density <code>ρ_A(ϵ) = Tr[A δ(ϵ-h)]</code> if <code>ket</code> is <code>missing</code>. If <code>ket</code> is an <code>AbstractMatrix</code> it evaluates the trace over the set of kets in <code>ket</code> (see <code>momentaKPM</code> and its options <code>kw</code> for further details). A tuple of energy points <code>xk</code> and <code>ρ_A</code> values is returned where the number of energy points <code>xk</code> is <code>order * resolution</code>, rounded to the closest integer.</p><pre><code class="language-none">densityKPM(momenta::MomentaKPM; resolution = 2)</code></pre><p>Same as above with the KPM momenta as input (see <code>momentaKPM</code>).</p><pre><code class="language-none">densityKPM(h::Hamiltonian, A::Hamiltonian; kw...)</code></pre><p>Equivalent to <code>densityKPM(bloch(h), bloch(A); kw...)</code> for finite Hamiltonians (zero dimensional).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/KPM.jl#LL277-L295">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.dims-Union{Tuple{Quantica.Lattice{E,L,T,B,U} where U&lt;:(Quantica.Unitcell{E,T,N} where N) where B&lt;:(Quantica.Bravais{E,L,T,EL} where EL) where T&lt;:AbstractFloat}, Tuple{L}, Tuple{E}} where L where E" href="#Quantica.dims-Union{Tuple{Quantica.Lattice{E,L,T,B,U} where U&lt;:(Quantica.Unitcell{E,T,N} where N) where B&lt;:(Quantica.Bravais{E,L,T,EL} where EL) where T&lt;:AbstractFloat}, Tuple{L}, Tuple{E}} where L where E"><code>Quantica.dims</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dims(lat::Lattice{E,L}) -&gt; (E, L)</code></pre><p>Return a tuple <code>(E, L)</code> of the embedding and lattice dimensions of <code>lat</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/lattice.jl#LL300-L304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.dosKPM-Tuple{Any}" href="#Quantica.dosKPM-Tuple{Any}"><code>Quantica.dosKPM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dosKPM(h::AbstractMatrix; resolution = 2, kw...)</code></pre><p>Compute, using the Kernel Polynomial Method (KPM), the local density of states <code>ρ(ϵ) = ⟨ket|δ(ϵ-h)|ket⟩/⟨ket|ket⟩</code> for a given <code>ket::AbstractVector</code> and hamiltonian <code>h</code>, or the global density of states <code>ρ(ϵ) = Tr[δ(ϵ-h)]</code> if <code>ket</code> is <code>missing</code>.</p><p>If <code>ket</code> is an <code>AbstractMatrix</code> it evaluates the trace over the set of kets in <code>ket</code> (see <code>momentaKPM</code> and its options <code>kw</code> for further details). The result is a tuple of energy points <code>xk::Vector</code> and real <code>ρ::Vector</code> values (any imaginary part in ρ is dropped), where the number of energy points <code>xk</code> is <code>order * resolution</code>, rounded to the closest integer.</p><pre><code class="language-none">dosKPM(μ::MomentaKPM; resolution = 2)</code></pre><p>Same as above with momenta <code>μ</code> as input.</p><pre><code class="language-none">dosKPM(h::Hamiltonian; kw...)</code></pre><p>Equivalent to <code>dosKPM(bloch(h); kw...)</code> for finite hamiltonians (zero dimensional).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/KPM.jl#LL252-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.energies-Tuple{Quantica.Spectrum}" href="#Quantica.energies-Tuple{Quantica.Spectrum}"><code>Quantica.energies</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">energies(s::Spectrum)</code></pre><p>Return the energies of <code>s</code> as a <code>Vector</code></p><p><strong>See also</strong></p><pre><code class="language-none">`spectrum`, `states`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/bandstructure.jl#LL39-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.flatten-Tuple{}" href="#Quantica.flatten-Tuple{}"><code>Quantica.flatten</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">flatten(h::Hamiltonian)</code></pre><p>Flatten a multiorbital Hamiltonian <code>h</code> into one with a single orbital per site. The associated lattice is flattened also, so that there is one site per orbital for each initial site (all at the same position). Note that in the case of sparse Hamiltonians, zeros in hopping/onsite matrices are preserved as structural zeros upon flattening.</p><pre><code class="language-none">h |&gt; flatten()</code></pre><p>Functional form equivalent to <code>flatten(h)</code> of <code>h |&gt; flatten</code> (included for consistency with the rest of the API).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; h = LatticePresets.honeycomb() |&gt;
           hamiltonian(hopping(@SMatrix[1; 2], range = 1/√3, sublats = :A =&gt;:B),
           orbitals = (Val(1), Val(2)))
Hamiltonian{&lt;:Lattice} : Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 3 (SparseMatrixCSC, sparse)
  Harmonic size    : 2 × 2
  Orbitals         : ((:a,), (:a, :a))
  Element type     : 2 × 2 blocks (Complex{Float64})
  Onsites          : 0
  Hoppings         : 3
  Coordination     : 1.5

julia&gt; flatten(h)
Hamiltonian{&lt;:Lattice} : Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 3 (SparseMatrixCSC, sparse)
  Harmonic size    : 3 × 3
  Orbitals         : ((:flat,), (:flat,))
  Element type     : scalar (Complex{Float64})
  Onsites          : 0
  Hoppings         : 6
  Coordination     : 2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/hamiltonian.jl#LL1180-L1218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.hamiltonian-Tuple{Any,Vararg{Any,N} where N}" href="#Quantica.hamiltonian-Tuple{Any,Vararg{Any,N} where N}"><code>Quantica.hamiltonian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hamiltonian(lat, model; orbitals, type)</code></pre><p>Create a <code>Hamiltonian</code> by applying <code>model::TighbindingModel</code> to the lattice <code>lat</code> (see <code>hopping</code> and <code>onsite</code> for details on building tightbinding models).</p><p>The number of orbitals on each sublattice can be specified by the keyword <code>orbitals</code> (otherwise all sublattices have one orbital by default). The following, and obvious combinations, are possible formats for the <code>orbitals</code> keyword:</p><pre><code class="language-none">orbitals = :a                # all sublattices have 1 orbital named :a
orbitals = (:a,)             # same as above
orbitals = (:a, :b, 3)       # all sublattices have 3 orbitals named :a and :b and :3
orbitals = ((:a, :b), (:c,)) # first sublattice has 2 orbitals, second has one
orbitals = ((:a, :b), :c)    # same as above
orbitals = (Val(2), Val(1))  # same as above, with automatic names
orbitals = (:A =&gt; (:a, :b), :D =&gt; :c) # sublattice :A has two orbitals, :D and rest have one
orbitals = :D =&gt; Val(4)      # sublattice :D has four orbitals, rest have one</code></pre><p>The matrix sizes of tightbinding <code>model</code> must match the orbitals specified. Internally, we define a block size <code>N = max(num_orbitals)</code>. If <code>N = 1</code> (all sublattices with one orbital) the the Hamiltonian element type is <code>type</code>. Otherwise it is <code>SMatrix{N,N,type}</code> blocks, padded with the necessary zeros as required. Keyword <code>type</code> is <code>Complex{T}</code> by default, where <code>T</code> is the number type of <code>lat</code>.</p><pre><code class="language-none">lat |&gt; hamiltonian(model; kw...)</code></pre><p>Functional <code>hamiltonian</code> form equivalent to <code>hamiltonian(lat, model[, funcmodel]; kw...)</code>.</p><p><strong>Indexing</strong></p><p>Indexing into a Hamiltonian <code>h</code> works as follows. Access the <code>HamiltonianHarmonic</code> matrix at a given <code>dn::NTuple{L,Int}</code> with <code>h[dn]</code>. Assign <code>v</code> into element <code>(i,j)</code> of said matrix with <code>h[dn][i,j] = v</code> or <code>h[dn, i, j] = v</code>. Broadcasting with vectors of indices <code>is</code> and <code>js</code> is supported, <code>h[dn][is, js] = v_matrix</code>.</p><p>To add an empty harmonic with a given <code>dn::NTuple{L,Int}</code>, do <code>push!(h, dn)</code>. To delete it, do <code>deleteat!(h, dn)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; h = hamiltonian(LatticePresets.honeycomb(), hopping(@SMatrix[1 2; 3 4], range = 1/√3), orbitals = Val(2))
Hamiltonian{&lt;:Lattice} : Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 5 (SparseMatrixCSC, sparse)
  Harmonic size    : 2 × 2
  Orbitals         : ((:a, :a), (:a, :a))
  Element type     : 2 × 2 blocks (Complex{Float64})
  Onsites          : 0
  Hoppings         : 6
  Coordination     : 3.0

julia&gt; push!(h, (3,3)) # Adding a new Hamiltonian harmonic (if not already present)
Hamiltonian{&lt;:Lattice} : Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 6 (SparseMatrixCSC, sparse)
  Harmonic size    : 2 × 2
  Orbitals         : ((:a, :a), (:a, :a))
  Element type     : 2 × 2 blocks (Complex{Float64})
  Onsites          : 0
  Hoppings         : 6
  Coordination     : 3.0

julia&gt; h[(3,3)][1,1] = @SMatrix[1 2; 2 1]; h[(3,3)] # element assignment
2×2 SparseMatrixCSC{StaticArrays.SArray{Tuple{2,2},Complex{Float64},2,4},Int64} with 1 stored entry:
  [1, 1]  =  [1.0+0.0im 2.0+0.0im; 2.0+0.0im 1.0+0.0im]

julia&gt; h[(3,3)][[1,2],[1,2]] .= Ref(@SMatrix[1 2; 2 1])
2×2 view(::SparseMatrixCSC{StaticArrays.SArray{Tuple{2,2},Complex{Float64},2,4},Int64}, [1, 2], [1, 2]) with eltype StaticArrays.SArray{Tuple{2,2},Complex{Float64},2,4}:
 [1.0+0.0im 2.0+0.0im; 2.0+0.0im 1.0+0.0im]  [1.0+0.0im 2.0+0.0im; 2.0+0.0im 1.0+0.0im]
 [1.0+0.0im 2.0+0.0im; 2.0+0.0im 1.0+0.0im]  [1.0+0.0im 2.0+0.0im; 2.0+0.0im 1.0+0.0im]</code></pre><p><strong>See also:</strong></p><pre><code class="language-none">`onsite`, `hopping`, `bloch`, `bloch!`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/hamiltonian.jl#LL188-L262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.hopping-Tuple{Any}" href="#Quantica.hopping-Tuple{Any}"><code>Quantica.hopping</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hopping(t; region = missing, sublats = missing, dn = missing, range = 1, plusadjoint = false)</code></pre><p>Create an <code>TightbindingModel</code> with a single <code>HoppingTerm</code> that applies a hopping <code>t</code> to a <code>Lattice</code> when creating a <code>Hamiltonian</code> with <code>hamiltonian</code>.</p><p>The hopping amplitude <code>t</code> can be a number, a matrix (preferably <code>SMatrix</code>), a <code>UniformScaling</code> (e.g. <code>3*I</code>) or a function of the form <code>(r, dr) -&gt; ...</code> for a position-dependent hopping (<code>r</code> is the bond center, and <code>dr</code> the bond vector). If <code>sublats</code> is specified as a sublattice name pair, or tuple thereof, <code>hopping</code> is only applied between sublattices with said names.</p><p>The dimension of <code>t::AbstractMatrix</code> must match the orbital dimension of applicable sublattices (see also <code>orbitals</code> option for <code>hamiltonian</code>). If <code>t::UniformScaling</code> it will be converted to a (possibly rectangular) identity matrix of the appropriate size when applied to multiorbital sublattices. Similarly, if <code>t::SMatrix</code> it will be truncated or padded to the appropriate size.</p><p><code>OnsiteTerm</code>s and <code>HoppingTerm</code>s created with <code>onsite</code> or <code>hopping</code> can be added or substracted together to build more complicated <code>TightbindingModel</code>s.</p><pre><code class="language-none">hopping(model::TightbindingModel; kw...)</code></pre><p>Return a <code>TightbindingModel</code> with only the hopping terms of <code>model</code>. Any non-missing <code>kw</code> is applied to all such terms.</p><p><strong>Keyword arguments</strong></p><p>Only hoppings between two sites at positions <code>r₁ = r - dr/2</code> and <code>r₂ = r + dr</code>, belonging to unit cells at integer distance <code>dn´</code> and to sublattices <code>s₁</code> and <code>s₂</code> will be selected if: <code>region(r, dr) &amp;&amp; s in sublats &amp;&amp; dn´ in dn &amp;&amp; norm(dr) &lt;= range</code>. If any of these is <code>missing</code> it will not be used to constraint the selection. Note that the default <code>range</code> is 1, not <code>missing</code>.</p><p>The keyword <code>dn</code> can be a <code>Tuple</code>/<code>Vector</code>/<code>SVector</code> of <code>Int</code>s, or a tuple thereof. The keyword <code>sublats</code> allows the following formats:</p><pre><code class="language-none">sublats = :A =&gt; :B                 # Hopping from :A to :B sublattices
sublats = (:A =&gt; :B,)              # Same as above
sublats = (:A =&gt; :B, :C =&gt; :D)     # Hopping from :A to :B or :C to :D
sublats = (:A, :C) .=&gt; (:B, :D)    # Broadcasted pairs, same as above
sublats = (:A, :C) =&gt; (:B, :D)     # Direct product, (:A=&gt;:B, :A=:D, :C=&gt;:B, :C=&gt;D)</code></pre><p>The keyword <code>plusadjoint</code> produces a model with the input hopping term plus its adjoint. Note that this substitution is made before multiplying by any coefficient, so that <code>im*hopping(..., plusadjoint = true) == im*(hopping(...) + hopping(...)&#39;)</code>.</p><p><strong>Combining models</strong></p><p><code>OnsiteTerm</code>s and <code>HoppingTerm</code>s created with <code>onsite</code> or <code>hopping</code> can added or substracted together or be multiplied by scalars to build more complicated <code>TightbindingModel</code>s, e.g. <code>onsite(1) - 3 * hopping(2)</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; model = 3 * onsite(1) - hopping(2, dn = ((1,2), (0,0)), sublats = :A=&gt;:B)
TightbindingModel{2}: model with 2 terms
  OnsiteTerm{Int64}:
    Sublattices      : any
    Coefficient      : 3
  HoppingTerm{Int64}:
    Sublattice pairs : (:A =&gt; :B,)
    dn cell distance : ([1, 2], [0, 0])
    Hopping range    : 1.0
    Coefficient      : -1

julia&gt; newmodel = onsite(model) + hopping(model, range = 2)
TightbindingModel{2}: model with 2 terms
  OnsiteTerm{Int64}:
    Sublattices      : any
    Coefficient      : 3
  HoppingTerm{Int64}:
    Sublattice pairs : (:A =&gt; :B,)
    dn cell distance : ([1, 2], [0, 0])
    Hopping range    : 2.0
    Coefficient      : -1

julia&gt; LatticePresets.honeycomb() |&gt; hamiltonian(hopping((r,dr) -&gt; cos(r[1]), sublats = (:A,:B) =&gt; (:A,:B)))
Hamiltonian{&lt;:Lattice} : Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 7 (SparseMatrixCSC, sparse)
  Harmonic size    : 2 × 2
  Orbitals         : ((:a,), (:a,))
  Element type     : scalar (Complex{Float64})
  Onsites          : 0
  Hoppings         : 18
  Coordination     : 9.0</code></pre><p><strong>See also:</strong></p><pre><code class="language-none">`onsite`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/model.jl#LL339-L430">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.lattice-Tuple{Quantica.Sublat,Vararg{Quantica.Sublat,N} where N}" href="#Quantica.lattice-Tuple{Quantica.Sublat,Vararg{Quantica.Sublat,N} where N}"><code>Quantica.lattice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lattice([bravais::Bravais,] sublats::Sublat...; dim::Val{E}, type::T, names)</code></pre><p>Create a <code>Lattice{E,L,T}</code> with Bravais matrix <code>bravais</code> and sublattices <code>sublats</code> converted to a common  <code>E</code>-dimensional embedding space and type <code>T</code>. To override the embedding  dimension <code>E</code>, use keyword <code>dim = Val(E)</code>. Similarly, override type <code>T</code> with <code>type = T</code>.</p><p>The keywords <code>names</code> can be used to rename <code>sublats</code>. Given names can be replaced to ensure that all sublattice names are unique.</p><p>See also <code>LatticePresets</code> for built-in lattices.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; lattice(bravais((1, 0)), sublat((0, 0)), sublat((0, Float32(1))); dim = Val(3))
Lattice{3,1,Float32} : 1D lattice in 3D space
  Bravais vectors : ((1.0f0, 0.0f0, 0.0f0),)
  Sublattices     : 2
    Names         : (:A, :B)
    Sites         : (1, 1) --&gt; 2 total per unit cell

julia&gt; LatticePresets.honeycomb(semibounded = 1, names = (:C, :D))
Lattice{2,2,Float64} : 2D lattice in 2D space
  Bravais vectors : ((0.5, 0.866025), (-0.5, 0.866025))
    Semibounded   : (1)
  Sublattices     : 2
    Names         : (:C, :D)
    Sites         : (1, 1) --&gt; 2 total per unit cell</code></pre><p><strong>See also:</strong></p><pre><code class="language-none">`LatticePresets`, `bravais`, `sublat`, `supercell`, `intracell`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/lattice.jl#LL254-L288">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.linearmesh-Tuple" href="#Quantica.linearmesh-Tuple"><code>Quantica.linearmesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">linearmesh(nodes...; points = 13, samelength = false, closed = false)</code></pre><p>Create a <code>MeshSpec</code> for a one-dimensional <code>Mesh</code> connecting the <code>nodes</code> with straight segments, each containing a number <code>points</code> of points (endpoints included). If a different number of points for each of the <code>N</code> segments is required, use <code>points::NTuple{N,Int}</code>. If <code>samelength</code> each segment has equal length in mesh coordinates. If <code>closed</code> the last node is connected to the first node (must be equal)</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; buildmesh(linearmesh(:Γ, :K, :M, :Γ; points = (101, 30, 30)), HamiltonianPresets.graphene())
Mesh{1}: mesh of a 1-dimensional manifold
  Vertices   : 159
  Edges      : 158</code></pre><p><strong>See also</strong></p><pre><code class="language-none">`marchingmesh`, `buildmesh`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/mesh.jl#LL257-L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.marchingmesh-Union{Tuple{Vararg{Tuple,L}}, Tuple{L}} where L" href="#Quantica.marchingmesh-Union{Tuple{Vararg{Tuple,L}}, Tuple{L}} where L"><code>Quantica.marchingmesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">marchingmesh(minmaxaxes...; axes = 1.0 * I, points = 13)</code></pre><p>Create a <code>MeshSpec</code> for a L-dimensional marching-tetrahedra <code>Mesh</code> over a parallelepiped with axes given by the columns of <code>axes</code>. The points along axis <code>i</code> are distributed between <code>first(minmaxaxes[i])</code> and <code>last(minmaxaxes[i])</code>. The number of points on each axis is given by <code>points</code>, or <code>points[i]</code> if several are given.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; buildmesh(marchingmesh((-π, π), (0,2π); points = 25))
Mesh{2}: mesh of a 2-dimensional manifold
  Vertices   : 625
  Edges      : 1776

julia&gt; buildmesh(marchingmesh((-π, π), (0,2π); points = (10,10)))
Mesh{2}: mesh of a 2-dimensional manifold
  Vertices   : 100
  Edges      : 261</code></pre><p><strong>See also</strong></p><pre><code class="language-none">`linearmesh`, `buildmesh`</code></pre><p><strong>External links</strong></p><ul><li>Marching tetrahedra (https://en.wikipedia.org/wiki/Marching_tetrahedra) in Wikipedia</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/mesh.jl#LL178-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.momentaKPM" href="#Quantica.momentaKPM"><code>Quantica.momentaKPM</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">momentaKPM(h::AbstractMatrix, A = I; ket = missing, order = 10, randomkets = 1, bandrange = missing)</code></pre><p>Compute the Kernel Polynomial Method (KPM) momenta <code>μ_n = ⟨ket|T_n(h) A|ket⟩/⟨ket|ket⟩</code> where <code>T_n(x)</code> is the Chebyshev polynomial of order <code>n</code>, for a given <code>ket::AbstractVector</code>, hamiltonian <code>h</code>, and observable <code>A</code>. If <code>ket</code> is <code>missing</code>, momenta are computed by means of a stochastic trace <code>μ_n = Tr[A T_n(h)] ≈ ∑ₐ⟨a|A T_n(h)|a⟩/N</code> over <code>N = randomkets</code> normalized random <code>|a⟩</code>. Furthermore, the trace over a specific set of kets can also be computed; in this case <code>ket::AbstractMatrix</code> must be a matrix where the columns are the kets involved in the calculation.</p><p>The order of the Chebyshev expansion is <code>order</code>. The <code>bandbrange = (ϵmin, ϵmax)</code> should completely encompass the full bandwidth of <code>hamiltonian</code>. If <code>missing</code> it is computed automatically using <code>ArnoldiMethods</code> (must be loaded).</p><p><strong>Examples</strong></p><pre><code class="language-none">julia&gt; h = LatticePresets.cubic() |&gt; hamiltonian(hopping(1)) |&gt; unitcell(region = RegionPresets.sphere(10));

julia&gt; momentaKPM(bloch(h), bandrange = (-6,6))
Quantica.MomentaKPM{Float64}([0.9594929736144973, -0.005881595972403821, -0.4933354572913581, 0.00359537502632597, 0.09759451291347333, -0.0008081453185250322, -0.00896262538765363, 0.00048205637037715177, -0.0003705198310034668, 9.64901673962623e-20, 9.110915988898614e-18], (0.0, 6.030150753768845))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/KPM.jl#LL60-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.offdiagonal-Tuple{Quantica.TightbindingModel,Any,Any}" href="#Quantica.offdiagonal-Tuple{Quantica.TightbindingModel,Any,Any}"><code>Quantica.offdiagonal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">offdiagonal(model, lat, nsublats::NTuple{N,Int})</code></pre><p>Build a restricted version of <code>model</code> that applies only to off-diagonal blocks formed by sublattice groups of size <code>nsublats</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/model.jl#LL460-L465">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.onsite-Tuple{Any}" href="#Quantica.onsite-Tuple{Any}"><code>Quantica.onsite</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">onsite(o; region = missing, sublats = missing)</code></pre><p>Create an <code>TightbindingModel</code> with a single <code>OnsiteTerm</code> that applies an onsite energy <code>o</code> to a <code>Lattice</code> when creating a <code>Hamiltonian</code> with <code>hamiltonian</code>.</p><p>The onsite energy <code>o</code> can be a number, a matrix (preferably <code>SMatrix</code>), a <code>UniformScaling</code> (e.g. <code>3*I</code>) or a function of the form <code>r -&gt; ...</code> for a position-dependent onsite energy.</p><p>The dimension of <code>o::AbstractMatrix</code> must match the orbital dimension of applicable sublattices (see also <code>orbitals</code> option for <code>hamiltonian</code>). If <code>o::UniformScaling</code> it will be converted to an identity matrix of the appropriate size when applied to multiorbital sublattices. Similarly, if <code>o::SMatrix</code> it will be truncated or padded to the appropriate size.</p><pre><code class="language-none">onsite(model::TightbindingModel; kw...)</code></pre><p>Return a <code>TightbindingModel</code> with only the onsite terms of <code>model</code>. Any non-missing <code>kw</code> is applied to all such terms.</p><p><strong>Keyword arguments</strong></p><p>Only sites at position <code>r</code> in sublattice with name <code>s::NameType</code> will be selected if <code>region(r) &amp;&amp; s in sublats</code> is true. Any missing <code>region</code> or <code>sublat</code> will not be used to constraint the selection.</p><p>The keyword <code>sublats</code> allows the following formats:</p><pre><code class="language-none">sublats = :A           # Onsite on sublat :A only
sublats = (:A,)        # Same as above
sublats = (:A, :B)     # Onsite on sublat :A and :B</code></pre><p><strong>Combining models</strong></p><p><code>OnsiteTerm</code>s and <code>HoppingTerm</code>s created with <code>onsite</code> or <code>hopping</code> can added or substracted together or be multiplied by scalars to build more complicated <code>TightbindingModel</code>s, e.g. <code>onsite(1) - 3 * hopping(2)</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; model = onsite(1, sublats = (:A,:B)) - 2 * hopping(2, sublats = :A=&gt;:A)
TightbindingModel{2}: model with 2 terms
  OnsiteTerm{Int64}:
    Sublattices      : (:A, :B)
    Coefficient      : 1
  HoppingTerm{Int64}:
    Sublattice pairs : (:A =&gt; :A,)
    dn cell distance : any
    Hopping range    : 1.0
    Coefficient      : -2

julia&gt; newmodel = onsite(model; sublats = :A) + hopping(model)
TightbindingModel{2}: model with 2 terms
  OnsiteTerm{Int64}:
    Sublattices      : (:A,)
    Coefficient      : 1
  HoppingTerm{Int64}:
    Sublattice pairs : (:A =&gt; :A,)
    dn cell distance : any
    Hopping range    : 1.0
    Coefficient      : -2

julia&gt; LatticePresets.honeycomb() |&gt; hamiltonian(onsite(r-&gt;@SMatrix[1 2; 3 4]), orbitals = Val(2))
Hamiltonian{&lt;:Lattice} : Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 1 (SparseMatrixCSC, sparse)
  Harmonic size    : 2 × 2
  Orbitals         : ((:a, :a), (:a, :a))
  Element type     : 2 × 2 blocks (Complex{Float64})
  Onsites          : 2
  Hoppings         : 0
  Coordination     : 0.0</code></pre><p><strong>See also:</strong></p><pre><code class="language-none">`hopping`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/model.jl#LL250-L326">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.optimize!-Union{Tuple{Quantica.Hamiltonian{#s35,L,M,A,H,O} where O&lt;:Tuple{Vararg{Tuple{Vararg{Symbol,N} where N},N} where N} where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where #s35&lt;:Quantica.Lattice}, Tuple{A}, Tuple{M}, Tuple{L}} where A&lt;:SparseMatrixCSC where M where L" href="#Quantica.optimize!-Union{Tuple{Quantica.Hamiltonian{#s35,L,M,A,H,O} where O&lt;:Tuple{Vararg{Tuple{Vararg{Symbol,N} where N},N} where N} where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where #s35&lt;:Quantica.Lattice}, Tuple{A}, Tuple{M}, Tuple{L}} where A&lt;:SparseMatrixCSC where M where L"><code>Quantica.optimize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">optimize!(h::Hamiltonian)</code></pre><p>Prepare a sparse Hamiltonian <code>h</code> to increase the performance of subsequent calls to <code>bloch(h, ϕs)</code> and <code>bloch!(matrix, h, ϕs)</code> by minimizing memory reshufflings. It also adds missing structural zeros to the diagonal to enable shifts by <code>α*I</code> (for shift-and-invert methods).</p><p>No optimization will be performed on non-sparse Hamiltonians, or those defined on <code>Superlattice</code>s, for which Bloch Hamiltonians are lazily evaluated.</p><p>Note that when calling <code>similarmatrix(h)</code> on a sparse <code>h</code>, <code>optimize!</code> is called first.</p><p><strong>See also:</strong></p><pre><code class="language-none">`bloch`, `bloch!`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/hamiltonian.jl#LL867-L882">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.parameters-Tuple{Quantica.ParametricHamiltonian}" href="#Quantica.parameters-Tuple{Quantica.ParametricHamiltonian}"><code>Quantica.parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parameters(ph::ParametricHamiltonian)</code></pre><p>Return the names of the parameter that <code>ph</code> depends on</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/parametric.jl#LL184-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.parameters-Tuple{Vararg{Quantica.ElementModifier,N} where N}" href="#Quantica.parameters-Tuple{Vararg{Quantica.ElementModifier,N} where N}"><code>Quantica.parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parameters(p::ElementModifier...)</code></pre><p>Return the parameter names for one or several  <code>ElementModifier</code> created with <code>@onsite!</code> or <code>@hopping!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/model.jl#LL518-L523">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.parametric-Tuple{Quantica.Hamiltonian,Vararg{Quantica.ElementModifier,N} where N}" href="#Quantica.parametric-Tuple{Quantica.Hamiltonian,Vararg{Quantica.ElementModifier,N} where N}"><code>Quantica.parametric</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parametric(h::Hamiltonian, modifiers::ElementModifier...)</code></pre><p>Builds a <code>ParametricHamiltonian</code> that can be used to efficiently apply <code>modifiers</code> to <code>h</code>. <code>modifiers</code> can be any number of <code>@onsite!(args -&gt; body; kw...)</code> and <code>@hopping!(args -&gt; body; kw...)</code> transformations, each with a set of parameters <code>ps</code> given as keyword arguments of functions <code>f = (...; ps...) -&gt; body</code>. The resulting <code>ph::ParamtricHamiltonian</code> can be used to produced the modified Hamiltonian simply by calling it with those same parameters as keyword arguments.</p><p>Note 1: for sparse <code>h</code>, <code>parametric</code> only modifies existing onsites and hoppings in <code>h</code>, so be sure to add zero onsites and/or hoppings to <code>h</code> if they are originally not present but you need to apply modifiers to them.</p><p>Note 2: <code>optimize!(h)</code> is called prior to building the parametric Hamiltonian. This can lead to extra zero onsites and hoppings being stored in sparse <code>h</code>s.</p><pre><code class="language-none">h |&gt; parametric(modifiers::ElementModifier...)</code></pre><p>Function form of <code>parametric</code>, equivalent to <code>parametric(h, modifiers...)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ph = LatticePresets.honeycomb() |&gt; hamiltonian(onsite(0) + hopping(1, range = 1/√3)) |&gt;
       unitcell(10) |&gt; parametric(@onsite!((o; μ) -&gt; o - μ))
ParametricHamiltonian{&lt;:Lattice} : Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 5 (SparseMatrixCSC, sparse)
  Harmonic size    : 200 × 200
  Orbitals         : ((:a,), (:a,))
  Element type     : scalar (Complex{Float64})
  Onsites          : 0
  Hoppings         : 600
  Coordination     : 3.0
  Parameters       : (:μ,)

julia&gt; ph(μ = 2)
Hamiltonian{&lt;:Lattice} : Hamiltonian on a 2D Lattice in 2D space
  Bloch harmonics  : 5 (SparseMatrixCSC, sparse)
  Harmonic size    : 200 × 200
  Orbitals         : ((:a,), (:a,))
  Element type     : scalar (Complex{Float64})
  Onsites          : 200
  Hoppings         : 600
  Coordination     : 3.0</code></pre><p><strong>See also</strong></p><pre><code class="language-none">`@onsite!`, `@hopping!`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/parametric.jl#LL20-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.permutations-Tuple{Any,Integer}" href="#Quantica.permutations-Tuple{Any,Integer}"><code>Quantica.permutations</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">permutations(a, t)</code></pre><p>Generate all size <code>t</code> permutations of an indexable object <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/tools.jl#LL240-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.permutations-Tuple{Any}" href="#Quantica.permutations-Tuple{Any}"><code>Quantica.permutations</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">permutations(a)</code></pre><p>Generate all permutations of an indexable object <code>a</code> in lexicographic order. Because the number of permutations can be very large, this function returns an iterator object. Use <code>collect(permutations(a))</code> to get an array of all permutations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/tools.jl#LL232-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.similarmatrix-Union{Tuple{Any}, Tuple{A´}, Tuple{Any,Type{A´}}} where A´&lt;:(AbstractArray{T,2} where T)" href="#Quantica.similarmatrix-Union{Tuple{Any}, Tuple{A´}, Tuple{Any,Type{A´}}} where A´&lt;:(AbstractArray{T,2} where T)"><code>Quantica.similarmatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">similarmatrix(h::Hamiltonian)</code></pre><p>Create an uninitialized matrix of the same type and size    of the Hamiltonian&#39;s matrix, calling <code>optimize!(h)</code> first to produce an optimal work matrix in the sparse case.</p><pre><code class="language-none">similarmatrix(h::Hamiltonian, T::Type{&lt;:AbstractMatrix})</code></pre><p>Specifies the desired type <code>T</code> of the uninitialized matrix.</p><pre><code class="language-none">similarmatrix(h::Hamiltonian, method::AbstractDiagonalizeMethod)</code></pre><p>Adapts the type of the matrix (e.g. dense/sparse) to the specified <code>method</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/hamiltonian.jl#LL821-L834">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.sites-Tuple{Quantica.AbstractLattice}" href="#Quantica.sites-Tuple{Quantica.AbstractLattice}"><code>Quantica.sites</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sites(lat[, sublat::Int])</code></pre><p>Extract the positions of all sites in a lattice, or in a specific sublattice</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/lattice.jl#LL510-L514">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.spectrum-Tuple{Any}" href="#Quantica.spectrum-Tuple{Any}"><code>Quantica.spectrum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">spectrum(h; method = defaultmethod(h), transform = missing)</code></pre><p>Compute the spectrum of a 0D Hamiltonian <code>h</code> (or alternatively of the bounded unit cell of a finite dimensional <code>h</code>) using one of the following <code>method</code>s</p><pre><code class="language-none">method                    diagonalization function
--------------------------------------------------------------
LinearAlgebraPackage()     LinearAlgebra.eigen!
ArpackPackage()            Arpack.eigs (must be `using Arpack`)</code></pre><p>The option <code>transform = ε -&gt; f(ε)</code> allows to transform eigenvalues by <code>f</code> in the returned spectrum (useful for performing shifts or other postprocessing).</p><p>The energies and eigenstates in the resulting <code>s::Spectrum</code> object can be accessed with <code>energies(s)</code> and <code>states(s)</code></p><p><strong>See also</strong></p><pre><code class="language-none">`energies`, `states`, `bandstructure`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/bandstructure.jl#LL9-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.states-Tuple{Quantica.Bandstructure,Any}" href="#Quantica.states-Tuple{Quantica.Bandstructure,Any}"><code>Quantica.states</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">states(bs::Bandstructure, i)</code></pre><p>Return the states of each vertex of the i-th band in <code>bs</code>, in the form of a <code>Matrix</code> of size <code>(nψ, nk)</code>, where <code>nψ</code> is the length of each state vector, and <code>nk</code> the number of vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/bandstructure.jl#LL113-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.states-Tuple{Quantica.Spectrum}" href="#Quantica.states-Tuple{Quantica.Spectrum}"><code>Quantica.states</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">states(s::Spectrum)</code></pre><p>Return the states of <code>s</code> as the columns of a <code>Matrix</code></p><p><strong>See also</strong></p><pre><code class="language-none">`spectrum`, `energies`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/bandstructure.jl#LL49-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.sublat-Tuple{Array{#s36,1} where #s36&lt;:(StaticArrays.SArray{Tuple{S},T,1,S} where T where S)}" href="#Quantica.sublat-Tuple{Array{#s36,1} where #s36&lt;:(StaticArrays.SArray{Tuple{S},T,1,S} where T where S)}"><code>Quantica.sublat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sublat(sites...; name::Symbol)
sublat(sites::Vector{&lt;:SVector}; name::Symbol)</code></pre><p>Create a <code>Sublat{E,T,D}</code> that adds a sublattice, of name <code>name</code>, with sites at positions <code>sites</code> in <code>E</code> dimensional space. Sites can be entered as tuples or <code>SVectors</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; sublat((0.0, 0), (1, 1), (1, -1), name = :A)
Sublat{2,Float64} : sublattice of Float64-typed sites in 2D space
  Sites    : 3
  Name     : :A</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/lattice.jl#LL26-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.supercell-Tuple{Vararg{Union{Integer, Tuple, StaticArrays.SArray{Tuple{S},T,1,S} where T where S, StaticArrays.SArray{Tuple{S1,S2},T,2,L} where L where T where S2 where S1},N} where N}" href="#Quantica.supercell-Tuple{Vararg{Union{Integer, Tuple, StaticArrays.SArray{Tuple{S},T,1,S} where T where S, StaticArrays.SArray{Tuple{S1,S2},T,2,L} where L where T where S2 where S1},N} where N}"><code>Quantica.supercell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">supercell(lat::AbstractLattice{E,L}, v::NTuple{L,Integer}...; region = missing, seed = missing)
supercell(lat::AbstractLattice{E,L}, sc::SMatrix{L,L´,Int}; region = missing, seed = missing)</code></pre><p>Generates a <code>Superlattice</code> from an <code>L</code>-dimensional lattice <code>lat</code> with Bravais vectors <code>br´= br * sc</code>, where <code>sc::SMatrix{L,L´,Int}</code> is the integer supercell matrix with the <code>L´</code> vectors <code>v</code>s as columns. If no <code>v</code> are given, the superlattice will be bounded. If <code>lat</code> has semibounded axes, these cannot be mixed with any other axes (they can only be removed, kept intact or scaled by a factor, see below).</p><p>Only sites at position <code>r</code> such that <code>region(r) == true</code> will be included in the supercell. The search for included sites will start from point <code>seed::Union{Tuple,SVector}</code>, or the origin if missing. If <code>region</code> is missing, a Bravais unit cell perpendicular to the <code>v</code> axes will be selected for the <code>L-L´</code> non-periodic directions.</p><pre><code class="language-none">supercell(lattice::AbstractLattice{E,L}, factor::Integer; kw...)</code></pre><p>Calls <code>supercell</code> with a uniformly scaled <code>sc = SMatrix{L,L}(factor * I)</code></p><pre><code class="language-none">supercell(lattice::AbstractLattice, factors::Integer...; kw...)</code></pre><p>Calls <code>supercell</code> with different scaling along each Bravais vector (diagonal supercell with factors along the diagonal)</p><pre><code class="language-none">lat |&gt; supercell(v...; kw...)</code></pre><p>Functional syntax, equivalent to `supercell(lat, v...; kw...)</p><pre><code class="language-none">supercell(h::Hamiltonian, v...; kw...)</code></pre><p>Promotes the <code>Lattice</code> of <code>h</code> to a <code>Superlattice</code> without changing the Hamiltonian itself, which always refers to the unitcell of the lattice.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; supercell(LatticePresets.honeycomb(), region = RegionPresets.circle(300))
Superlattice{2,2,Float64,0} : 2D lattice in 2D space, filling a 0D supercell
  Bravais vectors : ((0.5, 0.866025), (-0.5, 0.866025))
  Sublattices     : 2
    Names         : (:A, :B)
    Sites         : (1, 1) --&gt; 2 total per unit cell
  Supercell{2,0} for 0D superlattice of the base 2D lattice
    Supervectors  : ()
    Supersites    : 652966

julia&gt; supercell(LatticePresets.triangular(), (1,1), (1, -1))
Superlattice{2,2,Float64,2} : 2D lattice in 2D space, filling a 2D supercell
  Bravais vectors : ((0.5, 0.866025), (-0.5, 0.866025))
  Sublattices     : 1
    Names         : (:A)
    Sites         : (1) --&gt; 1 total per unit cell
  Supercell{2,2} for 2D superlattice of the base 2D lattice
    Supervectors  : ((1, 1), (1, -1))
    Supersites    : 2

julia&gt; LatticePresets.square() |&gt; supercell(3)
Superlattice{2,2,Float64,2} : 2D lattice in 2D space, filling a 2D supercell
  Bravais vectors : ((1.0, 0.0), (0.0, 1.0))
  Sublattices     : 1
    Names         : (:A)
    Sites         : (1) --&gt; 1 total per unit cell
  Supercell{2,2} for 2D superlattice of the base 2D lattice
    Supervectors  : ((3, 0), (0, 3))
    Supersites    : 9</code></pre><p><strong>See also:</strong></p><pre><code class="language-none">`unitcell`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/lattice.jl#LL585-L654">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.transform!-Tuple{Any,Quantica.Bandstructure}" href="#Quantica.transform!-Tuple{Any,Quantica.Bandstructure}"><code>Quantica.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(f::Function, b::Bandstructure)</code></pre><p>Transform the energies of all bands in <code>b</code> by applying <code>f</code> to them in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/bandstructure.jl#LL123-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.transform!-Tuple{Any,Quantica.Hamiltonian}" href="#Quantica.transform!-Tuple{Any,Quantica.Hamiltonian}"><code>Quantica.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(f::Function, h::Hamiltonian)</code></pre><p>Transform the site positions of the Hamiltonian&#39;s lattice in place without modifying the Hamiltonian harmonics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/hamiltonian.jl#LL349-L354">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.transform!-Tuple{Any,Quantica.Spectrum}" href="#Quantica.transform!-Tuple{Any,Quantica.Spectrum}"><code>Quantica.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(f::Function, s::Spectrum)</code></pre><p>Transform the energies of <code>s</code> by applying <code>f</code> to them in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/bandstructure.jl#LL59-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.transform!-Tuple{Function,Quantica.Lattice}" href="#Quantica.transform!-Tuple{Function,Quantica.Lattice}"><code>Quantica.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(f::Function, lat::Lattice)</code></pre><p>Transform the site positions of <code>lat</code> by applying <code>f</code> to them in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/lattice.jl#LL518-L522">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.unitcell-Tuple{Vararg{Union{Integer, Tuple, StaticArrays.SArray{Tuple{S},T,1,S} where T where S, StaticArrays.SArray{Tuple{S1,S2},T,2,L} where L where T where S2 where S1},N} where N}" href="#Quantica.unitcell-Tuple{Vararg{Union{Integer, Tuple, StaticArrays.SArray{Tuple{S},T,1,S} where T where S, StaticArrays.SArray{Tuple{S1,S2},T,2,L} where L where T where S2 where S1},N} where N}"><code>Quantica.unitcell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unitcell(lat::Lattice{E,L}, v::NTuple{L,Integer}...; region = missing, seed = missing)
unitcell(lat::Lattice{E,L}, uc::SMatrix{L,L´,Int}; region = missing, seed = missing)</code></pre><p>Generates a <code>Lattice</code> from an <code>L</code>-dimensional lattice <code>lat</code> and a larger unit cell, such that its Bravais vectors are <code>br´= br * uc</code>. Here <code>uc::SMatrix{L,L´,Int}</code> is the integer unitcell matrix, with the <code>L´</code> vectors <code>v</code>s as columns. If no <code>v</code> are given, the new lattice will be bounded.</p><p>Only sites at position <code>r</code> such that <code>region(r) == true</code> will be included in the new unitcell. The search for included sites will start from point <code>seed::Union{Tuple,SVector}</code>, or the origin if missing. If <code>region</code> is missing, a Bravais unitcell perpendicular to the <code>v</code> axes will be selected for the <code>L-L´</code> non-periodic directions.</p><pre><code class="language-none">unitcell(lattice::Lattice{E,L}, factor::Integer; kw...)</code></pre><p>Calls <code>unitcell</code> with a uniformly scaled <code>uc = SMatrix{L,L}(factor * I)</code></p><pre><code class="language-none">unitcell(lattice::Lattice{E,L}, factors::Integer...; kw...)</code></pre><p>Calls <code>unitcell</code> with different scaling along each Bravais vector (diagonal supercell with factors along the diagonal)</p><pre><code class="language-none">unitcell(slat::Superlattice)</code></pre><p>Convert Superlattice <code>slat</code> into a lattice with its unit cell matching <code>slat</code>&#39;s supercell.</p><pre><code class="language-none">unitcell(h::Hamiltonian, v...; modifiers = (), kw...)</code></pre><p>Transforms the <code>Lattice</code> of <code>h</code> to have a larger unitcell, while expanding the Hamiltonian accordingly. The modifiers (a tuple of <code>ElementModifier</code>s, either <code>@onsite!</code> or <code>@hopping!</code> with no free parameters) will be applied to onsite and hoppings as the hamiltonian is expanded. See <code>@onsite!</code> and <code>@hopping!</code> for details</p><p>Note: for performance reasons, in sparse hamiltonians only the stored onsites and hoppings will be transformed by <code>ElementModifier</code>s, so you might want to add zero onsites or hoppings when building <code>h</code> to have a modifier applied to them later. Note also that additional onsites and hoppings may be stored when calling <code>optimize!</code> or <code>bloch</code>/<code>bloch!</code> on <code>h</code> for the first time.</p><pre><code class="language-none">lat_or_h |&gt; unitcell(v...; kw...)</code></pre><p>Functional syntax, equivalent to `unitcell(lat<em>or</em>h, v...; kw...)</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; unitcell(LatticePresets.honeycomb(), region = RegionPresets.circle(300))
Lattice{2,0,Float64} : 0D lattice in 2D space
  Bravais vectors : ()
  Sublattices     : 2
    Names         : (:A, :B)
    Sites         : (326483, 326483) --&gt; 652966 total per unit cell

julia&gt; unitcell(LatticePresets.triangular(), (1,1), (1, -1))
Lattice{2,2,Float64} : 2D lattice in 2D space
  Bravais vectors : ((0.0, 1.732051), (1.0, 0.0))
  Sublattices     : 1
    Names         : (:A)
    Sites         : (2) --&gt; 2 total per unit cell

julia&gt; LatticePresets.square() |&gt; unitcell(3)
Lattice{2,2,Float64} : 2D lattice in 2D space
  Bravais vectors : ((3.0, 0.0), (0.0, 3.0))
  Sublattices     : 1
    Names         : (:A)
    Sites         : (9) --&gt; 9 total per unit cell

julia&gt; supercell(LatticePresets.square(), 3) |&gt; unitcell
Lattice{2,2,Float64} : 2D lattice in 2D space
  Bravais vectors : ((3.0, 0.0), (0.0, 3.0))
  Sublattices     : 1
    Names         : (:A)
    Sites         : (9) --&gt; 9 total per unit cell</code></pre><p><strong>See also:</strong></p><pre><code class="language-none">`supercell`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/lattice.jl#LL775-L853">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.vertices-Tuple{Quantica.Bandstructure,Any}" href="#Quantica.vertices-Tuple{Quantica.Bandstructure,Any}"><code>Quantica.vertices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vertices(bs::Bandstructure, i)</code></pre><p>Return the vertices <code>(k..., ϵ)</code> of the i-th band in <code>bs</code>, in the form of a <code>Vector{SVector{L+1}}</code>, where <code>L</code> is the lattice dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/bandstructure.jl#LL103-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.wrap-Union{Tuple{L}, Tuple{Quantica.Hamiltonian{#s36,L,M,A,H,O} where O&lt;:Tuple{Vararg{Tuple{Vararg{Symbol,N} where N},N} where N} where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where #s36&lt;:Quantica.Lattice,Any}} where L" href="#Quantica.wrap-Union{Tuple{L}, Tuple{Quantica.Hamiltonian{#s36,L,M,A,H,O} where O&lt;:Tuple{Vararg{Tuple{Vararg{Symbol,N} where N},N} where N} where H&lt;:Quantica.HamiltonianHarmonic{L,M,A} where A&lt;:(AbstractArray{T,2} where T) where M where #s36&lt;:Quantica.Lattice,Any}} where L"><code>Quantica.wrap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">wrap(h::Hamiltonian, axis::Int; factor = 1)</code></pre><p>Build a new Hamiltonian wherein the Bravais <code>axis</code> is wrapped into a loop. If a <code>factor</code> is given, the wrapped hoppings will be multiplied by said factor. This is useful to represent a flux Φ through the loop, if <code>factor = exp(im * 2π * Φ/Φ₀)</code>.</p><pre><code class="language-none">h |&gt; wrap(axis; kw...)</code></pre><p>Functional form equivalent to <code>wrap(h, axis; kw...)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; LatticePresets.honeycomb() |&gt; hamiltonian(hopping(1, range = 1/√3)) |&gt;
       unitcell((1,-1), (10, 10)) |&gt; wrap(2)
Hamiltonian{&lt;:Lattice} : Hamiltonian on a 1D Lattice in 2D space
  Bloch harmonics  : 3 (SparseMatrixCSC, sparse)
  Harmonic size    : 40 × 40
  Orbitals         : ((:a,), (:a,))
  Element type     : scalar (Complex{Float64})
  Onsites          : 0
  Hoppings         : 120
  Coordination     : 3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/hamiltonian.jl#LL730-L755">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.@hopping!-Tuple{Any,Any}" href="#Quantica.@hopping!-Tuple{Any,Any}"><code>Quantica.@hopping!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@hopping!(args -&gt; body; kw...)</code></pre><p>Create an <code>ElementModifier</code>, to be used with <code>parametric</code>, that applies <code>f = args -&gt; body</code> to hoppings energies specified by <code>kw</code> (see <code>hopping</code> for details on possible <code>kw</code>s). The form of <code>args -&gt; body</code> may be <code>(t; params...) -&gt; ...</code> or <code>(t, r, dr; params...) -&gt; ...</code> if the modification is position (<code>r</code>, <code>dr</code>) dependent. Keyword arguments <code>params</code> are optional, and include any parameters that <code>body</code> depends on that the user may want to tune.</p><p><strong>See also:</strong></p><pre><code class="language-none">`@onsite!`, `parametric`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/model.jl#LL551-L562">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Quantica.@onsite!-Tuple{Any,Any}" href="#Quantica.@onsite!-Tuple{Any,Any}"><code>Quantica.@onsite!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@onsite!(args -&gt; body; kw...)</code></pre><p>Create an <code>ElementModifier</code>, to be used with <code>parametric</code>, that applies <code>f = args -&gt; body</code> to onsite energies specified by <code>kw</code> (see <code>onsite</code> for details  on possible <code>kw</code>s). The form of <code>args -&gt; body</code> may be <code>(o; params...) -&gt; ...</code> or <code>(o, r; params...) -&gt; ...</code> if the modification is position (<code>r</code>) dependent. Keyword arguments <code>params</code> are optional, and include any parameters that <code>body</code> depends on that the user may want to tune.</p><p><strong>See also:</strong></p><pre><code class="language-none">`@hopping!`, `parametric`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pablosanjose/Quantica.jl/blob/68d5eab9bff25170af8a87c5f43d93d1aed2a526/src/model.jl#LL529-L540">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/">« Examples</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 17 July 2020 10:55">Friday 17 July 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
