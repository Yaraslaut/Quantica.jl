var documenterSearchIndex = {"docs":
[{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"CurrentModule = Quantica","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [Quantica]","category":"page"},{"location":"reference/#Quantica.Quantica","page":"Reference","title":"Quantica.Quantica","text":"Quantica.jl\n\n(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage) (Image: GitHub commits since last release)\n\nThe Quantica.jl package provides an expressive API to build arbitrary quantum systems on a discrete lattice, and to compute a number of their properties.\n\nSome current features\n\nBuild Hamiltonians on discrete lattices of arbitrary dimensions, using tight-binding models with arbitrary number of orbitals\nCompute band structures of periodic systems and extract individual bands by interpolation\nCompute electronic structures and expectation values using Kernel Polynomial methods\n\nExported API\n\nlattice, sublat: build lattices\nhopping, onsite, siteselector, hopselector, nrange, not: build tightbinding models\nhamiltonian: build a Hamiltonian from tightbinding model and a lattice\nparametric, @onsite!, @hopping!, parameters: build a parametric Hamiltonian\ndims, sitepositions, siteindices, bravais: inspect lattices and Hamiltonians\nsupercell, unitcell, flatten, wrap, transform!, combine: build derived lattices or Hamiltonians\nmarchingmesh, linearmesh: define a specification to build a bandstructure discretization mesh\nbandstructure, spectrum: compute the generalized bandstructure of a Hamiltonian or a ParametricHamiltonian\nbands, energies, states: inspect spectrum and bandstructure objects\nmomentaKPM, dosKPM, averageKPM, densityKPM, bandrangeKPM: Kernel Polynomial Method (KPM)\nket, randomkets: define ket models for use in e.g. KPM routines\ngreens, greensolver: build Green's functions of a Hamiltonian\n\nSome of this functionality require loading one or more third-party packages, which include the following:\n\nKPM: FFTW, ArnoldiMethod\nBandstructures: Arpack, ArnoldiMethod, KrylovKit\n\nThe user is told when this is needed. We do this to reduce dependencies and launch time with packages whose functionality is not essential for the use of Quantica.jl\n\nOther functions become available after loading specific third-party packages:\n\nMakie: enables plot(::Hamiltonian) and plot(::Bandstructure) (for 1D and 2D bandstructures)\nVegaLite: enables vlplot(::Hamiltonian) and vlplot(::Bandstructure) (for 1D bandstructures)\n\nFunding\n\nThis work has been partly funded by the Spanish Ministry of Economy and Competitiveness under Grant Nos. FIS2015-65706-P, PCI2018-093026, and the CSIC Intramural Project 201760I086.\n\n\n\n\n\n","category":"module"},{"location":"reference/#Base.Matrix-Tuple{Quantica.KetModel,Quantica.Hamiltonian}","page":"Reference","title":"Base.Matrix","text":"Matrix(km::KetModel, h::Hamiltonian; orthogonal = false)   Matrix(kms::NTuple{N,KetModel}, h::Hamiltonian, orthogonal = false)   Matrix(kms::AbstractMatrix, h::Hamiltonian; orthogonal = false)   Matrix(kms::StochasticTraceKets, h::Hamiltonian; orthogonal = false)\n\nConstruct an M×N Matrix representation of the N kets kms applied to M×M Hamiltonian h. If orthogonal = true, the columns are made orthogonal through a Gram-Schmidt process. If kms::StochasticTraceKets for n random kets (constructed with randomkets(n)), a normalization 1/√n required for stochastic traces is included.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.Vector-Tuple{Quantica.KetModel,Quantica.Hamiltonian}","page":"Reference","title":"Base.Vector","text":"Vector(km::KetModel, h::Hamiltonian)\n\nConstruct a Vector representation of km applied to Hamiltonian h.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.BoxIterator","page":"Reference","title":"Quantica.BoxIterator","text":"BoxIterator(seed::SVector{N,Int}; maxiterations = missing)\n\nCartesian iterator iter over SVector{N,Int}s (cells) that starts at seed and grows outwards in the form of a box of increasing sides (not necesarily equal) until it encompasses a certain N-dimensional region. To signal that a cell is in the desired region the user calls acceptcell!(iter, cell).\n\n\n\n\n\n","category":"type"},{"location":"reference/#Quantica.MeshSpec","page":"Reference","title":"Quantica.MeshSpec","text":"MeshSpec\n\nParent type of mesh specifications, which are currently MarchingMeshSpec (constructed with marchingmesh) and LinearMeshSpec (constructed with linearmesh).\n\nSee also\n\n`marchingmesh`, `linearmesh`, `buildmesh`\n\n\n\n\n\n","category":"type"},{"location":"reference/#Base.:&-Tuple{Quantica.Hamiltonian{#s38,L,M,A,H,O} where O<:Tuple{Vararg{Tuple{Vararg{Symbol,N} where N},N} where N} where H<:Quantica.HamiltonianHarmonic{L,M,A} where A<:(AbstractArray{T,2} where T) where M where L where #s38<:Quantica.Superlattice,Quantica.Hamiltonian{#s37,L,M,A,H,O} where O<:Tuple{Vararg{Tuple{Vararg{Symbol,N} where N},N} where N} where H<:Quantica.HamiltonianHarmonic{L,M,A} where A<:(AbstractArray{T,2} where T) where M where L where #s37<:Quantica.Superlattice}","page":"Reference","title":"Base.:&","text":"&(h1::Hamiltonian{<:Superlattice}, h2::Hamiltonian{<:Superlattice})\n\nConstruct a new Hamiltonian{<:Superlattice} using an and boolean mask, i.e. with a supercell that contains cells that are both in the supercell of h1 and h2\n\n&(s1::Superlattice, s2::Superlattice}\n\nEquivalent of the above for Superlattices\n\nSee also:\n\n`|`, `xor`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.:|-Tuple{Quantica.Hamiltonian{#s38,L,M,A,H,O} where O<:Tuple{Vararg{Tuple{Vararg{Symbol,N} where N},N} where N} where H<:Quantica.HamiltonianHarmonic{L,M,A} where A<:(AbstractArray{T,2} where T) where M where L where #s38<:Quantica.Superlattice,Quantica.Hamiltonian{#s37,L,M,A,H,O} where O<:Tuple{Vararg{Tuple{Vararg{Symbol,N} where N},N} where N} where H<:Quantica.HamiltonianHarmonic{L,M,A} where A<:(AbstractArray{T,2} where T) where M where L where #s37<:Quantica.Superlattice}","page":"Reference","title":"Base.:|","text":"|(h1::Hamiltonian{<:Superlattice}, h2::Hamiltonian{<:Superlattice})\n\nConstruct a new Hamiltonian{<:Superlattice} using an or boolean mask, i.e. with a supercell that contains cells that are either in the supercell of h1 or h2\n\n|(s1::Superlattice, s2::Superlattice}\n\nEquivalent of the above for Superlattices\n\nSee also:\n\n`&`, `xor`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.factorial-Union{Tuple{T}, Tuple{T,T}} where T<:Integer","page":"Reference","title":"Base.factorial","text":"factorial(n, k)\n\nCompute nk.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.xor-Tuple{Quantica.Hamiltonian{#s38,L,M,A,H,O} where O<:Tuple{Vararg{Tuple{Vararg{Symbol,N} where N},N} where N} where H<:Quantica.HamiltonianHarmonic{L,M,A} where A<:(AbstractArray{T,2} where T) where M where L where #s38<:Quantica.Superlattice,Quantica.Hamiltonian{#s37,L,M,A,H,O} where O<:Tuple{Vararg{Tuple{Vararg{Symbol,N} where N},N} where N} where H<:Quantica.HamiltonianHarmonic{L,M,A} where A<:(AbstractArray{T,2} where T) where M where L where #s37<:Quantica.Superlattice}","page":"Reference","title":"Base.xor","text":"xor(h1::Hamiltonian{<:Superlattice}, h2::Hamiltonian{<:Superlattice})\n\nConstruct a new Hamiltonian{<:Superlattice} using a xor boolean mask, i.e. with a supercell that contains cells that are either in the supercell of h1 or h2 but not in both\n\nxor(s1::Superlattice, s2::Superlattice}\n\nEquivalent of the above for Superlattices\n\nSee also:\n\n`&`, `|`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.averageKPM-Tuple{Any,Any}","page":"Reference","title":"Quantica.averageKPM","text":"averageKPM(h::Hamiltonian, A; kBT = 0, Ef = 0, kw...)\n\nCompute, using the Kernel Polynomial Method (KPM), the thermal expectation value <A> = Σ_k f(E_k) <k|A|k> = ∫dE f(E) Tr [A δ(E-H)] = Tr [A f(H)] for a given hermitian operator A and a zero-dimensional hamiltonian h (see momentaKPM and its options kw for further details). f(E) is the Fermi-Dirac distribution function, |k⟩ are h eigenstates with energy E_k, kBTis the temperature in energy units andEf` the Fermi energy.\n\naverageKPM(μ::MomentaKPM, A; kBT = 0, Ef = 0)\n\nSame as above with the KPM momenta as input (see momentaKPM).\n\nSee also:\n\n`dosKPM`, `momentaKPM`, `averageKPM`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.bands-Tuple{Quantica.Bandstructure}","page":"Reference","title":"Quantica.bands","text":"bands(bs::Bandstructure)\n\nReturn a vector of all the Bands in bs.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.bandstructure-Tuple{Quantica.Hamiltonian}","page":"Reference","title":"Quantica.bandstructure","text":"bandstructure(h::Hamiltonian; points = 13, kw...)\n\nCompute the bandstructure of h on a mesh over h's full Brillouin zone, with points points along each axis, spanning the interval [-π,π] along each reciprocal axis.\n\nbandstructure(h::Hamiltonian, spec::MeshSpec; lift = missing, kw...)\n\nCall bandstructure(h, mesh; lift = lift, kw...) with mesh = buildmesh(spec, h) and lift = buildlift(spec, h) if not provided. See MeshSpec for available mesh specs. If the lift = missing and the dimensions of the mesh do not match the Hamiltonian's, a lift function is used that lifts the mesh onto the dimensions h by appending vertex coordinates with zeros.\n\nbandstructure(h::Hamiltonian, mesh::Mesh; lift = missing, kw...)\n\nCompute the bandstructure bandstructure(h, mesh; kw...) of Bloch Hamiltonian bloch(h, ϕ), with ϕ = v taken on each vertex v of mesh (or ϕ = lift(v...) if a lift function is provided).\n\nbandstructure(ph::ParametricHamiltonian, ...; kw...)\n\nCompute the bandstructure of a ph with i parameters (see parameters(ph)), where mesh is interpreted as a discretization of parameter space ⊗ Brillouin zone, so that each vertex reads v = (p₁,..., pᵢ, ϕ₁,..., ϕⱼ), with p the values assigned to parameters(ph) and ϕᵢ the Bloch phases.\n\nbandstructure(matrixf::Function, mesh::Mesh; kw...)\n\nCompute the bandstructure of the Hamiltonian matrix m = matrixf(ϕ), with ϕ evaluated on the vertices v of the mesh. Note that ϕ in matrixf(ϕ) is an unsplatted container. Hence, i.e. matrixf(x) = ... or matrixf(x, y) = ... will not work, use matrixf((x,)) = ... or matrixf((x, y)) = ... instead.\n\nh |> bandstructure([mesh,]; kw...)\n\nCurried form of the above equivalent to bandstructure(h, [mesh]; kw...).\n\nOptions\n\nThe default options are\n\n(lift = missing, minoverlap = 0.5, method = defaultmethod(h), transform = missing)\n\nlift: when not missing, lift is a function lift = (vs...) -> ϕ, where vs are the coordinates of a mesh vertex and ϕ are Bloch phases if sampling a h::Hamiltonian, or (paramsⱼ..., ϕᵢ...) if sampling a ph::ParametricHamiltonian, and params are values for parameters(ph). It represents a mapping from a mesh and a Brillouin/parameter space. This allows to compute a bandstructure along a cut in the Brillouin zone/parameter space, see below for examples.\n\nThe option minoverlap determines the minimum overlap between eigenstates to connect them into a common subband.\n\nmethod: it is chosen automatically if unspecified, and can be one of the following\n\nmethod                     diagonalization function\n--------------------------------------------------------------\nLinearAlgebraPackage()     LinearAlgebra.eigen!\nArpackPackage()            Arpack.eigs (must be `using Arpack`)\n\nOptions passed to the method will be forwarded to the diagonalization function. For example, method = ArpackPackage(nev = 8, sigma = 1im) will use Arpack.eigs(matrix; nev = 8, sigma = 1im) to compute the bandstructure.\n\ntransform: the option transform = ε -> f(ε) allows to transform eigenvalues by f in the returned bandstructure (useful for performing shifts or other postprocessing).\n\nExamples\n\njulia> h = LatticePresets.honeycomb() |> hamiltonian(hopping(-1, range = 1/√3)) |> unitcell(3);\n\njulia> bandstructure(h; points = 25, method = LinearAlgebraPackage())\nBandstructure{2}: collection of 2D bands\n  Bands        : 8\n  Element type : scalar (Complex{Float64})\n  Mesh{2}: mesh of a 2-dimensional manifold\n    Vertices   : 625\n    Edges      : 1776\n\njulia> bandstructure(h, linearmesh(:Γ, :X, :Y, :Γ))\nBandstructure{1}: collection of 1D bands\n  Bands        : 17\n  Element type : scalar (Complex{Float64})\n  Mesh{1}: mesh of a 1-dimensional manifold\n    Vertices   : 37\n    Edges      : 36\n\njulia> bandstructure(h, marchingmesh((0, 2π); points = 25); lift = φ -> (φ, 0))\n       # Equivalent to bandstructure(h, linearmesh(:Γ, :X; points = 11))\nBandstructure{1}: collection of 1D bands\n  Bands        : 18\n  Element type : scalar (Complex{Float64})\n  Mesh{1}: mesh of a 1-dimensional manifold\n    Vertices   : 25\n    Edges      : 24\n\nSee also\n\n`marchingmesh`, `linearmesh`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.bloch","page":"Reference","title":"Quantica.bloch","text":"bloch(h::Hamiltonian{<:Lattice}, ϕs)\n\nBuild the Bloch Hamiltonian matrix of h, for Bloch phases ϕs = (ϕ₁, ϕ₂,...) (or an SVector(ϕs...)). In terms of Bloch wavevector k, ϕs = k * bravais(h), it is defined as H(ϕs) = ∑exp(-im * ϕs' * dn) h_dn where h_dn are Bloch harmonics connecting unit cells at a distance dR = bravais(h) * dn.\n\nbloch(h::Hamiltonian{<:Lattice})\n\nBuild the intra-cell Hamiltonian matrix of h, without adding any Bloch harmonics.\n\nbloch(h::Hamiltonian{<:Lattice}, ϕs, axis::Int)\n\nA nonzero axis produces the derivative of the Bloch matrix respect to ϕs[axis] (i.e. the velocity operator along this axis), ∂H(ϕs) = ∑ -im * dn[axis] * exp(-im * ϕs' * dn) h_dn\n\nbloch(matrix, h::Hamiltonian{<:Lattice}, ϕs::NTuple{L,Real}, dnfunc::Function)\n\nGeneralization that applies a prefactor dnfunc(dn) * exp(im * ϕs' * dn) to the dn harmonic.\n\nbloch(ph::ParametricHamiltonian, pϕs, [axis])\n\nSame as above, but with pϕs = (p₁,...,pᵢ, ϕ₁, ..., ϕⱼ), with p values for parameters(ph) and ϕ Bloch phases.\n\nh |> bloch(ϕs, ...)\n\nCurried forms of bloch, equivalent to bloch(h, ϕs, ...)\n\nNotes\n\nbloch allocates a new matrix on each call. For a non-allocating version of bloch, see bloch!.\n\nExamples\n\njulia> h = LatticePresets.honeycomb() |> hamiltonian(onsite(1) + hopping(2)) |> bloch((0, 0))\n2×2 SparseMatrixCSC{Complex{Float64},Int64} with 4 stored entries:\n  [1, 1]  =  13.0+0.0im\n  [2, 1]  =  6.0+0.0im\n  [1, 2]  =  6.0+0.0im\n  [2, 2]  =  13.0+0.0im\n\nSee also:\n\n`bloch!`, `optimize!`, `similarmatrix`\n\n\n\n\n\n","category":"function"},{"location":"reference/#Quantica.bloch!","page":"Reference","title":"Quantica.bloch!","text":"bloch!(matrix, h::Hamiltonian, ϕs, [axis])\n\nIn-place version of bloch. Overwrite matrix with the Bloch Hamiltonian matrix of h for the specified Bloch phases ϕs = (ϕ₁,ϕ₂,...) (see bloch for definition and API).  A conventient way to obtain a matrix is to use similarmatrix(h,...), which will return an AbstractMatrix of the same type as the Hamiltonian's. Note, however, that matrix need not be of the same type (e.g. it can be dense with Number eltype for a sparse h with SMatrix block eltype).\n\nbloch!(matrix, ph::ParametricHamiltonian, pϕs, [axis])\n\nSame as above, but with pϕs = (p₁,...,pᵢ, ϕ₁, ..., ϕⱼ), with p values for parameters(ph) and ϕ Bloch phases.\n\nExamples\n\njulia> h = LatticePresets.honeycomb() |> hamiltonian(hopping(2I), orbitals = (Val(2), Val(1)));\n\njulia> bloch!(similarmatrix(h), h, (0, 0))\n2×2 SparseMatrixCSC{StaticArrays.SArray{Tuple{2,2},Complex{Float64},2,4},Int64} with 4 stored entries:\n  [1, 1]  =  [12.0+0.0im 0.0+0.0im; 0.0+0.0im 12.0+0.0im]\n  [2, 1]  =  [6.0+0.0im 0.0+0.0im; 0.0+0.0im 0.0+0.0im]\n  [1, 2]  =  [6.0+0.0im 0.0+0.0im; 0.0+0.0im 0.0+0.0im]\n  [2, 2]  =  [12.0+0.0im 0.0+0.0im; 0.0+0.0im 0.0+0.0im]\n\njulia> bloch!(similarmatrix(h, AbstractMatrix{ComplexF64}), h, (0, 0))\n3×3 SparseMatrixCSC{Complex{Float64},Int64} with 9 stored entries:\n  [1, 1]  =  12.0+0.0im\n  [2, 1]  =  0.0+0.0im\n  [3, 1]  =  6.0+0.0im\n  [1, 2]  =  0.0+0.0im\n  [2, 2]  =  12.0+0.0im\n  [3, 2]  =  0.0+0.0im\n  [1, 3]  =  6.0+0.0im\n  [2, 3]  =  0.0+0.0im\n  [3, 3]  =  12.0+0.0im\n\njulia> ph = parametric(h, @hopping!((t; α) -> α * t));\n\njulia> bloch!(similarmatrix(ph, AbstractMatrix{ComplexF64}), ph, (2, 0, 0))\n3×3 SparseMatrixCSC{Complex{Float64},Int64} with 9 stored entries:\n  [1, 1]  =  24.0+0.0im\n  [2, 1]  =  0.0+0.0im\n  [3, 1]  =  12.0+0.0im\n  [1, 2]  =  0.0+0.0im\n  [2, 2]  =  24.0+0.0im\n  [3, 2]  =  0.0+0.0im\n  [1, 3]  =  12.0+0.0im\n  [2, 3]  =  0.0+0.0im\n  [3, 3]  =  24.0+0.0im\n\nSee also:\n\n`bloch`, `optimize!`, `similarmatrix`\n\n\n\n\n\n","category":"function"},{"location":"reference/#Quantica.bravais-Tuple{Quantica.AbstractLattice}","page":"Reference","title":"Quantica.bravais","text":"bravais(lat::Lattice)\nbravais(h::Hamiltonian)\n\nObtain the Bravais matrix of lattice lat or Hamiltonian h\n\nExamples\n\njulia> bravais((1.0, 2), (3, 4))\nBravais{2,2,Float64} : set of 2 Bravais vectors in 2D space.\n  Vectors     : ((1.0, 2.0), (3.0, 4.0))\n  Matrix      : [1.0 3.0; 2.0 4.0]\n\nSee also:\n\n`lattice`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.buildlift-Tuple{Quantica.MeshSpec,Union{Quantica.Hamiltonian, Quantica.ParametricHamiltonian}}","page":"Reference","title":"Quantica.buildlift","text":"buildlift(s::MeshSpec{L}, h::Union{Hamiltonian,ParametricHamiltonian})\n\nBuild a lift function that maps a Mesh built with buildmesh(s, h) to the Brillouin/parameter space of h (see bandstructure for details).\n\nSee also\n\n`buildmesh`, `marchingmesh`, `linearmesh`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.buildmesh-Tuple{Quantica.MeshSpec,Union{Quantica.Hamiltonian, Quantica.ParametricHamiltonian}}","page":"Reference","title":"Quantica.buildmesh","text":"buildmesh(s::MeshSpec, h::Union{Hamiltonian,ParametricHamiltonian})\n\nBuild a Mesh from the spec s, using properties of h as needed. The use of h depends on the spec. For a LinearMeshSpec with samelength = false, the Bravais matrix of h is needed to work out the length of each mesh segment in the Brillouin zone, while for other specs such as MarchingMeshSpec, h is not needed and may be omitted (see example).\n\nExamples\n\njulia> buildmesh(marchingmesh((-π, π), (0, 2π), points = 10))\nMesh{2}: mesh of a 2-dimensional manifold\n  Vertices   : 100\n  Edges      : 261\n\nSee also\n\n`buildlift`, `marchingmesh`, `linearmesh`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.combine-Tuple{Vararg{Quantica.Hamiltonian,N} where N}","page":"Reference","title":"Quantica.combine","text":"combine(hams::Hamiltonian...; coupling = missing)\n\nBuild a new Hamiltonian h that combines all hams as diagonal blocks, and applies coupling::Model, if provided, to build the off-diagonal couplings. Note that the diagonal blocks are not modified by the coupling model.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.combine-Tuple{Vararg{Quantica.Lattice,N} where N}","page":"Reference","title":"Quantica.combine","text":"combine(lats::Lattice...)\n\nIf all lats have compatible Bravais vectors, combine them into a single lattice. Sublattice names are renamed to be unique if necessary.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.densityKPM-Tuple{Any,Any}","page":"Reference","title":"Quantica.densityKPM","text":"densityKPM(h::Hamiltonian, A; resolution = 2, kets = randomkets(1), kw...)\n\nCompute, using the Kernel Polynomial Method (KPM), the spectral density of A for zero-dimensional Hamiltonian h, ρ_A(ϵ) = ∑⟨ket|A δ(ϵ-h)|ket⟩/R ≈ Tr[Aδ(ϵ-h)] (the sum is over R random kets). A can itself be a Hamiltonian or a UniformScaling λ*I. If kets are not randomkets but one or more KetModels (see ket), the division by R is ommitted, which results in a local spectral density ρ_A(ϵ) = ∑⟨ket|Aδ(ϵ-h)|ket⟩ at sites specified by kets.\n\nThe result is a tuple of energy points xk::Vector and real ρ_A::Vector values (unlike for dosKPM, all imaginary parts in ρ_A are preserved), where the number of energy points xk is order * resolution, rounded to the closest integer.\n\ndensityKPM(momenta::MomentaKPM; resolution = 2)\n\nSame as above with the KPM momenta as input (see momentaKPM).\n\nSee also:\n\n`dosKPM`, `momentaKPM`, `averageKPM`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.dosKPM-Tuple{Any}","page":"Reference","title":"Quantica.dosKPM","text":"dosKPM(h::Hamiltonian; resolution = 2, kets = randomkets(1), kw...)\n\nCompute, using the Kernel Polynomial Method (KPM), the density of states per site of zero-dimensional Hamiltonian h, ρ(ϵ) = ∑⟨ket|δ(ϵ-h)|ket⟩/(NR) ≈ Tr[δ(ϵ-h)]/N (N is the number of sites, and the sum is over R random kets). If kets are not randomkets but one or more KetModels (see ket), the division by NR is ommitted, which results in a local density of states ρ(ϵ) = ∑⟨ket|δ(ϵ-h)|ket⟩ at sites specified by kets.\n\nThe result is a tuple of energy points xk::Vector and real ρ::Vector values (any residual imaginary part in ρ is dropped), where the number of energy points xk is order * resolution, rounded to the closest integer.\n\ndosKPM(μ::MomentaKPM; resolution = 2)\n\nSame as above with KPM momenta μ as input. Equivalent to densityKPM(μ; kw...) except that imaginary parts are dropped.\n\nSee also:\n\n`momentaKPM`, `densityKPM`, `averageKPM`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.energies-Tuple{Quantica.Bandstructure}","page":"Reference","title":"Quantica.energies","text":"energies(b::Bandstructure)\n\nReturn the sorted unique energies of b as a Vector\n\nSee also\n\n`bandstructure`, `states`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.energies-Tuple{Quantica.Spectrum}","page":"Reference","title":"Quantica.energies","text":"energies(s::Spectrum)\n\nReturn the energies of s as a Vector\n\nSee also\n\n`spectrum`, `states`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.flatten-Tuple{}","page":"Reference","title":"Quantica.flatten","text":"flatten(h::Hamiltonian)\n\nFlatten a multiorbital Hamiltonian h into one with a single orbital per site. The associated lattice is flattened also, so that there is one site per orbital for each initial site (all at the same position). Note that in the case of sparse Hamiltonians, zeros in hopping/onsite matrices are preserved as structural zeros upon flattening.\n\nh |> flatten()\n\nCurried form equivalent to flatten(h) of h |> flatten (included for consistency with the rest of the API).\n\nExamples\n\njulia> h = LatticePresets.honeycomb() |>\n           hamiltonian(hopping(@SMatrix[1; 2], range = 1/√3, sublats = :A =>:B),\n           orbitals = (Val(1), Val(2)))\nHamiltonian{<:Lattice} : Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 3 (SparseMatrixCSC, sparse)\n  Harmonic size    : 2 × 2\n  Orbitals         : ((:a,), (:a, :a))\n  Element type     : 2 × 2 blocks (Complex{Float64})\n  Onsites          : 0\n  Hoppings         : 3\n  Coordination     : 1.5\n\njulia> flatten(h)\nHamiltonian{<:Lattice} : Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 3 (SparseMatrixCSC, sparse)\n  Harmonic size    : 3 × 3\n  Orbitals         : ((:flat,), (:flat,))\n  Element type     : scalar (Complex{Float64})\n  Onsites          : 0\n  Hoppings         : 6\n  Coordination     : 2.0\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.greens-Tuple{Any,Any}","page":"Reference","title":"Quantica.greens","text":"greens(h::Hamiltonian, solveobject)\n\nConstruct the Green's function g::GreensFunction of h using the provided solveobject. Currently valid solveobjects are\n\nthe Bandstructure of h (for an unbounded h or an Hamiltonian{<:Superlattice}})\nthe Spectrum of h (for a bounded h)\nh |> greens(h -> solveobject(h))\n\nCurried form equivalent to the above, giving greens(h, solveobject(h)) (see example below).\n\ng([m,] ω, cells::Pair = missing)\n\nFrom a constructed g::GreensFunction, obtain the retarded Green's function matrix at frequency ω between unit cells src and dst by calling g(ω, src => dst), where src, dst are ::NTuple{L,Int} or SVector{L,Int}. If cells is missing, src and dst are assumed to be zero vectors. For performance, one can use a preallocated matrix m (e.g. m = similarmatrix(h)) by calling g(m, ω, cells).\n\nExamples\n\njulia> g = LatticePresets.square() |> hamiltonian(hopping(-1)) |> greens(bandstructure(resolution = 17))\nGreensFunction{Bandstructure}: Green's function from a 2D bandstructure\n  Matrix size    : 1 × 1\n  Element type   : scalar (Complex{Float64})\n  Band simplices : 512\n\njulia> g(0.2)\n1×1 Array{Complex{Float64},2}:\n 6.663377810046025 - 24.472789025006396im\n\njulia> m = similarmatrix(g); g(m, 0.2)\n1×1 Array{Complex{Float64},2}:\n 6.663377810046025 - 24.472789025006396im\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.hamiltonian-Tuple{Quantica.AbstractLattice,Vararg{Any,N} where N}","page":"Reference","title":"Quantica.hamiltonian","text":"hamiltonian(lat, model; orbitals, type)\n\nCreate a Hamiltonian by applying model::TighbindingModel to the lattice lat (see hopping and onsite for details on building tightbinding models).\n\nThe number of orbitals on each sublattice can be specified by the keyword orbitals (otherwise all sublattices have one orbital by default). The following, and obvious combinations, are possible formats for the orbitals keyword:\n\norbitals = :a                # all sublattices have 1 orbital named :a\norbitals = (:a,)             # same as above\norbitals = (:a, :b, 3)       # all sublattices have 3 orbitals named :a and :b and :3\norbitals = ((:a, :b), (:c,)) # first sublattice has 2 orbitals, second has one\norbitals = ((:a, :b), :c)    # same as above\norbitals = (Val(2), Val(1))  # same as above, with automatic names\norbitals = (:A => (:a, :b), :D => :c) # sublattice :A has two orbitals, :D and rest have one\norbitals = :D => Val(4)      # sublattice :D has four orbitals, rest have one\n\nThe matrix sizes of tightbinding model must match the orbitals specified. Internally, we define a block size N = max(num_orbitals). If N = 1 (all sublattices with one orbital) the the Hamiltonian element type is type. Otherwise it is SMatrix{N,N,type} blocks, padded with the necessary zeros as required. Keyword type is Complex{T} by default, where T is the number type of lat.\n\nlat |> hamiltonian(model; kw...)\n\nCurried form of hamiltonian equivalent to hamiltonian(lat, model[, funcmodel]; kw...).\n\nIndexing\n\nIndexing into a Hamiltonian h works as follows. Access the HamiltonianHarmonic matrix at a given dn::NTuple{L,Int} with h[dn]. Assign v into element (i,j) of said matrix with h[dn][i,j] = v or h[dn, i, j] = v. Broadcasting with vectors of indices is and js is supported, h[dn][is, js] = v_matrix.\n\nTo add an empty harmonic with a given dn::NTuple{L,Int}, do push!(h, dn). To delete it, do deleteat!(h, dn).\n\nExamples\n\njulia> h = hamiltonian(LatticePresets.honeycomb(), hopping(@SMatrix[1 2; 3 4], range = 1/√3), orbitals = Val(2))\nHamiltonian{<:Lattice} : Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 5 (SparseMatrixCSC, sparse)\n  Harmonic size    : 2 × 2\n  Orbitals         : ((:a, :a), (:a, :a))\n  Element type     : 2 × 2 blocks (Complex{Float64})\n  Onsites          : 0\n  Hoppings         : 6\n  Coordination     : 3.0\n\njulia> push!(h, (3,3)) # Adding a new Hamiltonian harmonic (if not already present)\nHamiltonian{<:Lattice} : Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 6 (SparseMatrixCSC, sparse)\n  Harmonic size    : 2 × 2\n  Orbitals         : ((:a, :a), (:a, :a))\n  Element type     : 2 × 2 blocks (Complex{Float64})\n  Onsites          : 0\n  Hoppings         : 6\n  Coordination     : 3.0\n\njulia> h[(3,3)][1,1] = @SMatrix[1 2; 2 1]; h[(3,3)] # element assignment\n2×2 SparseMatrixCSC{StaticArrays.SArray{Tuple{2,2},Complex{Float64},2,4},Int64} with 1 stored entry:\n  [1, 1]  =  [1.0+0.0im 2.0+0.0im; 2.0+0.0im 1.0+0.0im]\n\njulia> h[(3,3)][[1,2],[1,2]] .= Ref(@SMatrix[1 2; 2 1])\n2×2 view(::SparseMatrixCSC{StaticArrays.SArray{Tuple{2,2},Complex{Float64},2,4},Int64}, [1, 2], [1, 2]) with eltype StaticArrays.SArray{Tuple{2,2},Complex{Float64},2,4}:\n [1.0+0.0im 2.0+0.0im; 2.0+0.0im 1.0+0.0im]  [1.0+0.0im 2.0+0.0im; 2.0+0.0im 1.0+0.0im]\n [1.0+0.0im 2.0+0.0im; 2.0+0.0im 1.0+0.0im]  [1.0+0.0im 2.0+0.0im; 2.0+0.0im 1.0+0.0im]\n\nSee also:\n\n`onsite`, `hopping`, `bloch`, `bloch!`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.hopping-Tuple{Any}","page":"Reference","title":"Quantica.hopping","text":"hopping(t; range = nrange(1), dn = missing, sublats = missing, indices = missing, region = missing, plusadjoint = false)\n\nCreate an TightbindingModel with a single HoppingTerm that applies a hopping t to a Lattice when creating a Hamiltonian with hamiltonian.\n\nThe hopping amplitude t can be a number, an SMatrix, a UniformScaling (e.g. 3*I) or a function of the form (r, dr) -> ... for a position-dependent hopping (r is the bond center, and dr the bond vector). If sublats is specified as a sublattice name pair, or tuple thereof, hopping is only applied between sublattices with said names.\n\nThe dimension of t::AbstractMatrix must match the orbital dimension of applicable sublattices (see also orbitals option for hamiltonian). If t::UniformScaling it will be converted to a (possibly rectangular) identity matrix of the appropriate size when applied to multiorbital sublattices. Similarly, if t::SMatrix it will be truncated or padded to the appropriate size.\n\nOnsiteTerms and HoppingTerms created with onsite or hopping can be added or substracted together to build more complicated TightbindingModels.\n\nhopping(model::TightbindingModel; kw...)\n\nReturn a TightbindingModel with only the hopping terms of model. Any non-missing kw is applied to all such terms.\n\nKeyword arguments\n\nMost keywords are the same as for hopselector. Only hoppings between two sites at positions r₁ = r - dr/2 and r₂ = r + dr, belonging to unit cells at integer distance dn´ and to sublattices s₁ and s₂ will be selected if: region(r, dr) && s in sublats && dn´ in dn && norm(dr) <= range. If any of these is missing it will not be used to constraint the selection.\n\nThe keyword range admits the following possibilities\n\nmax_range                   # i.e. `norm(dr) <= max_range`\n(min_range, max_range)      # i.e. `min_range <= norm(dr) <= max_range`\n\nBoth max_range and min_range can be a Real or a NeighborRange created with nrange(n). The latter represents the distance of n-th nearest neighbors. Note that the range default for hopping (unlike for the more general hopselector) is nrange(1), i.e. first-nearest-neighbors.\n\nThe keyword dn can be a Tuple/Vector/SVector of Ints, or a tuple thereof. The keyword sublats allows the following formats:\n\nsublats = :A => :B                 # Hopping from :A to :B sublattices\nsublats = (:A => :B,)              # Same as above\nsublats = (:A => :B, :C => :D)     # Hopping from :A to :B or :C to :D\nsublats = (:A, :C) .=> (:B, :D)    # Broadcasted pairs, same as above\nsublats = (:A, :C) => (:B, :D)     # Direct product, (:A=>:B, :A=:D, :C=>:B, :C=>D)\n\nThe keyword plusadjoint produces a model with the input hopping term plus its adjoint. Note that this substitution is made before multiplying by any coefficient, so that im*hopping(..., plusadjoint = true) == im*(hopping(...) + hopping(...)').\n\nCombining models\n\nOnsiteTerms and HoppingTerms created with onsite or hopping can added or substracted together or be multiplied by scalars to build more complicated TightbindingModels, e.g. onsite(1) - 3 * hopping(2)\n\nExamples\n\njulia> model = 3 * onsite(1) - hopping(2, dn = ((1,2), (0,0)), sublats = :A=>:B)\nTightbindingModel{2}: model with 2 terms\n  OnsiteTerm{Int64}:\n    Sublattices      : any\n    Coefficient      : 3\n  HoppingTerm{Int64}:\n    Sublattice pairs : (:A => :B,)\n    dn cell distance : ([1, 2], [0, 0])\n    Hopping range    : 1.0\n    Coefficient      : -1\n\njulia> newmodel = onsite(model) + hopping(model, range = 2)\nTightbindingModel{2}: model with 2 terms\n  OnsiteTerm{Int64}:\n    Sublattices      : any\n    Coefficient      : 3\n  HoppingTerm{Int64}:\n    Sublattice pairs : (:A => :B,)\n    dn cell distance : ([1, 2], [0, 0])\n    Hopping range    : 2.0\n    Coefficient      : -1\n\njulia> LatticePresets.honeycomb() |> hamiltonian(hopping((r,dr) -> cos(r[1]), sublats = (:A,:B) => (:A,:B)))\nHamiltonian{<:Lattice} : Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 7 (SparseMatrixCSC, sparse)\n  Harmonic size    : 2 × 2\n  Orbitals         : ((:a,), (:a,))\n  Element type     : scalar (Complex{Float64})\n  Onsites          : 0\n  Hoppings         : 18\n  Coordination     : 9.0\n\nSee also:\n\n`onsite`, `nrange`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.hopselector-Tuple{}","page":"Reference","title":"Quantica.hopselector","text":"hopselector(; range = missing, dn = missing, sublats = missing, indices = missing, region = missing)\n\nReturn a HopSelector object that can be used to select hops between two sites in a lattice. Only hops between two sites, with indices ipair = src => dst, at positions r₁ = r - dr/2 and r₂ = r + dr, belonging to unit cells at integer distance dn´ and to sublattices s₁ and s₂ will be selected if:\n\n`region(r, dr) && s in sublats && dn´ in dn && norm(dr) <= range && ipair in indices`\n\nIf any of these is missing it will not be used to constraint the selection.\n\nThe keyword range admits the following possibilities\n\nmax_range                   # i.e. `norm(dr) <= max_range`\n(min_range, max_range)      # i.e. `min_range <= norm(dr) <= max_range`\n\nBoth max_range and min_range can be a Real or a NeighborRange created with nrange(n). The latter represents the distance of n-th nearest neighbors.\n\nThe keyword dn can be a Tuple/Vector/SVector of Ints, or a tuple thereof.\n\nThe keyword sublats allows the following formats:\n\nsublats = :A => :B                  # Hopping from :A to :B sublattices, but not from :B to :A\nsublats = (:A => :B,)               # Same as above\nsublats = (:A => :B, :C => :D)      # Hopping from :A to :B or :C to :D\nsublats = (:A, :C) .=> (:B, :D)     # Broadcasted pairs, same as above\nsublats = (:A, :C) => (:B, :D)      # Direct product, (:A=>:B, :A=:D, :C=>:B, :C=>D)\n\nThe keyword indices accepts a single src => dest pair or a collection thereof. Any src == dest will be neglected. Possible combinations:\n\nindices = 1 => 2                    # Hopping from site 1 to 2, but not from 2 to 1\nindices = (1 => 2, 2 => 1)          # Hoppings from 1 to 2 or from 2 to 1\nindices = [1 => 2, 2 => 1]          # Same as above\nindices = [(1, 2) .=> (2, 1)]       # Broadcasted pairs, same as above\nindices = [1:10 => 20:25, 3 => 30]  # Direct product, any hopping from sites 1:10 to sites 20:25, or from 3 to 30\n\nAdditionally, indices or sublattices can be wrapped in not to exclude them (see not):\n\nsublats = not(:A => :B, :B => :A)   # Any sublat pairs different from :A => :B or :B => :A\nsublats = not(:A) => :B             # Any sublat pair s1 => s2 with s1 different from :A and s2 equal to :B\nindices = not(8 => 9)               # Any site indices different from 8 => 9\nindices = 1 => not(3:4)             # Any site pair 1 => s with s different from 3, 4\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.ket-Tuple{Any}","page":"Reference","title":"Quantica.ket","text":"ket(a; region = missing, sublats = missing, normalized = true, maporbitals = false)\n\nCreate an KetModel of amplitude a on the specified region and sublats. The amplitude a can be a number, an SVector, or a function of the form r -> ... for a position-dependent amplitude.\n\nUnless maporbitals = true, the dimension of a::AbstractVector must match the orbital dimension of applicable sublattices (see also orbitals option for hamiltonian).\n\nOne or more k::KetModel can be converted to a Vector or Matrix representation corresponding to Hamiltonian h with Vector(k, h) and Matrix(k, h), see Vector and Matrix.\n\nKeyword arguments\n\nKeyword normalized indicates whether to force normalization of the ket when the KetModel is applied to a specific Hamiltonian.\n\nIf keyword maporbitals == true and a is a scalar or a scalar function, a will be applied to each orbital independently. This is particularly useful in multiorbital systems with random amplitudes, e.g. a = randn(). If a is not a scalar, a convert error will be thrown.\n\nKeywords region and sublats are the same as for siteselector. Only sites at position r in sublattice with name s::NameType will be selected if region(r) && s in sublats is true. Any missing region or sublat will not be used to constraint the selection.\n\nThe keyword sublats allows the following formats:\n\nsublats = :A           # Onsite on sublat :A only\nsublats = (:A,)        # Same as above\nsublats = (:A, :B)     # Onsite on sublat :A and :B\n\nKet algebra\n\nKetModels created with ket can added or substracted together or be multiplied by scalars to build more elaborate KetModels, e.g. ket(1) - 3 * ket(2, region = r -> norm(r) < 10)\n\nExamples\n\njulia> k = ket(1, sublats=:A) - ket(1, sublats=:B)\nKetModel{2}: model with 2 terms\n  Normalized : false\n  OnsiteTerm{Int64}:\n    Sublattices      : (:A,)\n    Coefficient      : 1\n  OnsiteTerm{Int64}:\n    Sublattices      : (:B,)\n    Coefficient      : -1\n\nSee also:\n\n`onsite`, `Vector`, `Matrix`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.lattice-Tuple{Vararg{Quantica.Sublat,N} where N}","page":"Reference","title":"Quantica.lattice","text":"lattice(sublats::Sublat...; bravais = (), dim::Val{E}, type::T, names = missing)\n\nCreate a Lattice{E,L,T} with Bravais vectors bravais and sublattices sublats converted to a common  E-dimensional embedding space and type T. To override the embedding  dimension E, use keyword dim = Val(E). Similarly, override type T with type = T.\n\nThe keyword bravais indicates one or more Bravais vectors in the form of tuples or other iterables. It can also be an AbstractMatrix of dimension E×L. The default bravais = () corresponds to a bounded lattice with no Bravais vectors.\n\nA keyword names can be used to rename sublats. Given names can be replaced to ensure that all sublattice names are unique.\n\nlattice(lat::AbstractLattice; bravais = missing, dim = missing, type = missing, names = missing)\n\nCreate a new lattice by applying any non-missing kw to lat. For performance, allocations will be avoided if possible (depends on kw), so the result can share memory of lat. To avoid that, do lattice(copy(lat); kw...).\n\nSee also LatticePresets for built-in lattices.\n\nExamples\n\njulia> lattice(sublat((0, 0)), sublat((0, Float32(1))); bravais = (1, 0), dim = Val(3))\nLattice{3,1,Float32} : 1D lattice in 3D space\n  Bravais vectors : ((1.0f0, 0.0f0, 0.0f0),)\n  Sublattices     : 2\n    Names         : (:A, :B)\n    Sites         : (1, 1) --> 2 total per unit cell\n\njulia> LatticePresets.honeycomb(names = (:C, :D))\nLattice{2,2,Float64} : 2D lattice in 2D space\n  Bravais vectors : ((0.5, 0.866025), (-0.5, 0.866025))\n  Sublattices     : 2\n    Names         : (:C, :D)\n    Sites         : (1, 1) --> 2 total per unit cell\n\njulia> LatticePresets.cubic(bravais = ((1, 0), (0, 2)))\nLattice{3,2,Float64} : 2D lattice in 3D space\n  Bravais vectors : ((1.0, 0.0, 0.0), (0.0, 2.0, 0.0))\n  Sublattices     : 1\n    Names         : (:A)\n    Sites         : (1) --> 1 total per unit cell\n\nSee also:\n\n`LatticePresets`, `bravais`, `sublat`, `supercell`, `intracell`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.linearmesh-Tuple","page":"Reference","title":"Quantica.linearmesh","text":"linearmesh(nodes...; points = 13, samelength = false, closed = false)\n\nCreate a MeshSpec for a one-dimensional Mesh connecting the nodes with straight segments, each containing a number points of points (endpoints included). If a different number of points for each of the N segments is required, use points::NTuple{N,Int}. If samelength each segment has equal length in mesh coordinates. If closed the last node is connected to the first node (must be equal)\n\nExamples\n\njulia> buildmesh(linearmesh(:Γ, :K, :M, :Γ; points = (101, 30, 30)), HamiltonianPresets.graphene())\nMesh{1}: mesh of a 1-dimensional manifold\n  Vertices   : 159\n  Edges      : 158\n\nSee also\n\n`marchingmesh`, `buildmesh`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.marchingmesh-Union{Tuple{Vararg{Tuple,L}}, Tuple{L}} where L","page":"Reference","title":"Quantica.marchingmesh","text":"marchingmesh(minmaxaxes...; axes = 1.0 * I, points = 13)\n\nCreate a MeshSpec for a L-dimensional marching-tetrahedra Mesh over a parallelepiped with axes given by the columns of axes. The points along axis i are distributed between first(minmaxaxes[i]) and last(minmaxaxes[i]). The number of points on each axis is given by points, or points[i] if several are given.\n\nExamples\n\njulia> buildmesh(marchingmesh((-π, π), (0,2π); points = 25))\nMesh{2}: mesh of a 2-dimensional manifold\n  Vertices   : 625\n  Edges      : 1776\n\njulia> buildmesh(marchingmesh((-π, π), (0,2π); points = (10,10)))\nMesh{2}: mesh of a 2-dimensional manifold\n  Vertices   : 100\n  Edges      : 261\n\nSee also\n\n`linearmesh`, `buildmesh`\n\nExternal links\n\nMarching tetrahedra (https://en.wikipedia.org/wiki/Marching_tetrahedra) in Wikipedia\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.momentaKPM","page":"Reference","title":"Quantica.momentaKPM","text":"momentaKPM(h::Hamiltonian, A = I; kets = randomkets(1), order = 10, bandrange = missing)\n\nCompute the Kernel Polynomial Method (KPM) momenta μ_n = ∑⟨ket|T_n(h) A|ket⟩, where the sum is over kets and where T_n(x) is the Chebyshev polynomial of order n, for a given ket, hamiltonian h, and observable A.\n\nkets can be a KetModel or a tuple of KetModels (see ket and randomkets). A kets = randomkets(R, ...) produces a special RepeatedKets object that can be used to compute momenta by means of a stochastic trace μ_n = Tr[A T_n(h)] ≈ ∑ₐ⟨a|A T_n(h)|a⟩, where the |a⟩ are the R random kets of norm 1/√R.\n\nThe order of the Chebyshev expansion is order. The bandbrange = (ϵmin, ϵmax) should completely encompass the full bandwidth of hamiltonian. If missing it is computed automatically using ArnoldiMethods (must be loaded).\n\nExamples\n\njulia> h = LatticePresets.cubic() |> hamiltonian(hopping(1)) |> unitcell(region = RegionPresets.sphere(10));\n\njulia> momentaKPM(h, bandrange = (-6,6)).mulist |> length\n11\n\n\n\n\n\n","category":"function"},{"location":"reference/#Quantica.not-Tuple{Any}","page":"Reference","title":"Quantica.not","text":"not(i)\n\nWrapper indicating the negation or complement of i, typically used to encode excluded site indices. See siteselector and hopselector for applications.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.nrange-Tuple{Int64}","page":"Reference","title":"Quantica.nrange","text":"nrange(n::Int)\n\nCreate a NeighborRange that represents a hopping range to distances corresponding to the n-th nearest neighbors in a given lattice. Such distance is obtained by finding the n-th closest pairs of sites in a lattice, irrespective of their sublattice.\n\nnrange(n::Int, lat::AbstractLattice)\n\nObtain the actual nth-nearest-neighbot distance between sites in lattice lat.\n\nSee also:\n\n`hopping`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.offdiagonal-Tuple{Quantica.TightbindingModel,Any,Any}","page":"Reference","title":"Quantica.offdiagonal","text":"offdiagonal(model, lat, nsublats::NTuple{N,Int})\n\nBuild a restricted version of model that applies only to off-diagonal blocks formed by sublattice groups of size nsublats.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.onsite-Tuple{Any}","page":"Reference","title":"Quantica.onsite","text":"onsite(o; region = missing, sublats = missing)\n\nCreate an TightbindingModel with a single OnsiteTerm that applies an onsite energy o to a Lattice when creating a Hamiltonian with hamiltonian.\n\nThe onsite energy o can be a number, an SMatrix, a UniformScaling (e.g. 3*I) or a function of the form r -> ... for a position-dependent onsite energy.\n\nThe dimension of o::AbstractMatrix must match the orbital dimension of applicable sublattices (see also orbitals option for hamiltonian). If o::UniformScaling it will be converted to an identity matrix of the appropriate size when applied to multiorbital sublattices. Similarly, if o::SMatrix it will be truncated or padded to the appropriate size.\n\nonsite(model::TightbindingModel; kw...)\n\nReturn a TightbindingModel with only the onsite terms of model. Any non-missing kw is applied to all such terms.\n\nKeyword arguments\n\nKeywords are the same as for siteselector. Only sites at position r in sublattice with name s::NameType will be selected if region(r) && s in sublats is true. Any missing region or sublat will not be used to constraint the selection.\n\nThe keyword sublats allows the following formats:\n\nsublats = :A           # Onsite on sublat :A only\nsublats = (:A,)        # Same as above\nsublats = (:A, :B)     # Onsite on sublat :A and :B\n\nCombining models\n\nOnsiteTerms and HoppingTerms created with onsite or hopping can added or substracted together or be multiplied by scalars to build more complicated TightbindingModels, e.g. onsite(1) - 3 * hopping(2)\n\nExamples\n\njulia> model = onsite(1, sublats = (:A,:B)) - 2 * hopping(2, sublats = :A=>:A)\nTightbindingModel{2}: model with 2 terms\n  OnsiteTerm{Int64}:\n    Sublattices      : (:A, :B)\n    Coefficient      : 1\n  HoppingTerm{Int64}:\n    Sublattice pairs : (:A => :A,)\n    dn cell distance : any\n    Hopping range    : 1.0\n    Coefficient      : -2\n\njulia> newmodel = onsite(model; sublats = :A) + hopping(model)\nTightbindingModel{2}: model with 2 terms\n  OnsiteTerm{Int64}:\n    Sublattices      : (:A,)\n    Coefficient      : 1\n  HoppingTerm{Int64}:\n    Sublattice pairs : (:A => :A,)\n    dn cell distance : any\n    Hopping range    : 1.0\n    Coefficient      : -2\n\njulia> LatticePresets.honeycomb() |> hamiltonian(onsite(r -> @SMatrix[1 2; 3 4]), orbitals = Val(2))\nHamiltonian{<:Lattice} : Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 1 (SparseMatrixCSC, sparse)\n  Harmonic size    : 2 × 2\n  Orbitals         : ((:a, :a), (:a, :a))\n  Element type     : 2 × 2 blocks (Complex{Float64})\n  Onsites          : 2\n  Hoppings         : 0\n  Coordination     : 0.0\n\nSee also:\n\n`hopping`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.optimize!-Union{Tuple{Quantica.Hamiltonian{#s35,L,M,A,H,O} where O<:Tuple{Vararg{Tuple{Vararg{Symbol,N} where N},N} where N} where H<:Quantica.HamiltonianHarmonic{L,M,A} where #s35<:Quantica.Lattice}, Tuple{A}, Tuple{M}, Tuple{L}} where A<:SparseMatrixCSC where M where L","page":"Reference","title":"Quantica.optimize!","text":"optimize!(h::Hamiltonian)\n\nPrepare a sparse Hamiltonian h to increase the performance of subsequent calls to bloch(h, ϕs) and bloch!(matrix, h, ϕs) by minimizing memory reshufflings. It also adds missing structural zeros to the diagonal to enable shifts by α*I (for shift-and-invert methods).\n\nNo optimization will be performed on non-sparse Hamiltonians, or those defined on Superlattices, for which Bloch Hamiltonians are lazily evaluated.\n\nNote that when calling similarmatrix(h) on a sparse h, optimize! is called first.\n\nSee also:\n\n`bloch`, `bloch!`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.parameters-Tuple{Quantica.ParametricHamiltonian}","page":"Reference","title":"Quantica.parameters","text":"parameters(ph::ParametricHamiltonian)\n\nReturn the names of the parameter that ph depends on\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.parameters-Tuple{Vararg{Quantica.ElementModifier,N} where N}","page":"Reference","title":"Quantica.parameters","text":"parameters(p::ElementModifier...)\n\nReturn the parameter names for one or several  ElementModifier created with @onsite! or @hopping!\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.parametric-Tuple{Quantica.Hamiltonian,Vararg{Quantica.ElementModifier,N} where N}","page":"Reference","title":"Quantica.parametric","text":"parametric(h::Hamiltonian, modifiers::ElementModifier...)\n\nBuilds a ParametricHamiltonian that can be used to efficiently apply modifiers to h. modifiers can be any number of @onsite!(args -> body; kw...) and @hopping!(args -> body; kw...) transformations, each with a set of parameters ps given as keyword arguments of functions f = (...; ps...) -> body. The resulting ph::ParamtricHamiltonian can be used to produced the modified Hamiltonian simply by calling it with those same parameters as keyword arguments.\n\nNote 1: for sparse h, parametric only modifies existing onsites and hoppings in h, so be sure to add zero onsites and/or hoppings to h if they are originally not present but you need to apply modifiers to them.\n\nNote 2: optimize!(h) is called prior to building the parametric Hamiltonian. This can lead to extra zero onsites and hoppings being stored in sparse hs.\n\nh |> parametric(modifiers::ElementModifier...)\n\nFunction form of parametric, equivalent to parametric(h, modifiers...).\n\nExamples\n\njulia> ph = LatticePresets.honeycomb() |> hamiltonian(onsite(0) + hopping(1, range = 1/√3)) |>\n       unitcell(10) |> parametric(@onsite!((o; μ) -> o - μ))\nParametricHamiltonian{<:Lattice} : Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 5 (SparseMatrixCSC, sparse)\n  Harmonic size    : 200 × 200\n  Orbitals         : ((:a,), (:a,))\n  Element type     : scalar (Complex{Float64})\n  Onsites          : 0\n  Hoppings         : 600\n  Coordination     : 3.0\n  Parameters       : (:μ,)\n\njulia> ph(μ = 2)\nHamiltonian{<:Lattice} : Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 5 (SparseMatrixCSC, sparse)\n  Harmonic size    : 200 × 200\n  Orbitals         : ((:a,), (:a,))\n  Element type     : scalar (Complex{Float64})\n  Onsites          : 200\n  Hoppings         : 600\n  Coordination     : 3.0\n\nSee also\n\n`@onsite!`, `@hopping!`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.permutations-Tuple{Any,Integer}","page":"Reference","title":"Quantica.permutations","text":"permutations(a, t)\n\nGenerate all size t permutations of an indexable object a.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.permutations-Tuple{Any}","page":"Reference","title":"Quantica.permutations","text":"permutations(a)\n\nGenerate all permutations of an indexable object a in lexicographic order. Because the number of permutations can be very large, this function returns an iterator object. Use collect(permutations(a)) to get an array of all permutations.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.randomkets","page":"Reference","title":"Quantica.randomkets","text":"randomkets(n, f::Function = r -> cis(2pi*rand()); orthogonal = false, maporbitals = false, kw...)\n\nCreate a StochasticTraceKets object to use in stochastic trace evaluation of KPM methods. The ket amplitudes at point r is given by function f(r). In order to produce an accurate estimate of traces ∑⟨ket|A|ket⟩/n ≈ TrA, f must be a random function satisfying ⟨f⟩ = 0, ⟨ff⟩ = 0 and ⟨f'f⟩ = 1. The default f produces a uniform random phase. To apply it to an N-orbital system, f must in general be adapted to produce the desired random SVector{N} (unless maporbitals = true), with the above statistical properties for each orbital.\n\nFor example, to have independent, complex, normally-distributed random components of two orbitals use randomkets(n, r -> randn(SVector{2,ComplexF64})), or alternatively randomkets(n, r -> randn(ComplexF64), maporbitals = true).\n\nIf orthogonal == true the random kets are made orthogonal after sampling. This option is currently only available for scalar ket eltype. The remaining keywords kw are passed to ket and can be used to constrain the random amplitude to a subset of sites. normalized, however, is always false.\n\nSee also:\n\n`ket`\n\n\n\n\n\n","category":"function"},{"location":"reference/#Quantica.similarmatrix-Union{Tuple{Any}, Tuple{A´}, Tuple{Any,Type{A´}}} where A´<:(AbstractArray{T,2} where T)","page":"Reference","title":"Quantica.similarmatrix","text":"similarmatrix(h::Hamiltonian)\n\nCreate an uninitialized matrix of the same type and size of the Hamiltonian's matrix, calling optimize!(h) first to produce an optimal work matrix in the sparse case.\n\nsimilarmatrix(h::Hamiltonian, T::Type{<:AbstractMatrix})\n\nSpecifies the desired type T of the uninitialized matrix.\n\nsimilarmatrix(h::Hamiltonian, method::AbstractDiagonalizeMethod)\n\nAdapts the type of the matrix (e.g. dense/sparse) to the specified method\n\nsimilarmatrix(x::Union{ParametricHamiltonian, GreensFunction}, ...)\n\nEquivalent to the above, but adapted to the more general type of x.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.siteindices-Tuple{Quantica.AbstractLattice}","page":"Reference","title":"Quantica.siteindices","text":"siteindices(lat::AbstractLattice; kw...)\nsiteindices(lat::Hamiltonian; kw...)\n\nBuild a generator of the unique indices of sites in the lattice unitcell. Only sites specified by siteselector(kw...) are selected, see siteselector for details.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.sitepositions-Tuple{Quantica.AbstractLattice}","page":"Reference","title":"Quantica.sitepositions","text":"sitepositions(lat::AbstractLattice; kw...)\nsitepositions(h::Hamiltonian; kw...)\n\nBuild a generator of the positions of sites in the lattice unitcell. Only sites specified by siteselector(kw...) are selected, see siteselector for details.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.siteselector-Tuple{}","page":"Reference","title":"Quantica.siteselector","text":"siteselector(; region = missing, sublats = missing, indices = missing)\n\nReturn a SiteSelector object that can be used to select sites in a lattice contained within the specified region and sublattices. Only sites with index i, at position r and belonging to a sublattice with name s::NameType will be selected if\n\n`region(r) && s in sublats && i in indices`\n\nAny missing region, sublat or indices will not be used to constraint the selection.\n\nThe keyword sublats allows the following formats:\n\nsublats = :A                    # Sites on sublat :A only\nsublats = (:A,)                 # Same as above\nsublats = (:A, :B)              # Sites on sublat :A and :B\n\nThe keyword indices accepts a single integer, or a collection thereof. If several collections are given, they are flattened into a single one. Possible combinations:\n\nindices = 1                     # Site 1 only\nindices = (1, )                 # Same as above\nindices = (1, 2, 3)             # Sites 1, 2 or 3\nindices = [1, 2, 3]             # Same as above\nindices = 1:3                   # Same as above\nindices = (1:3, 7, 8)           # Sites 1, 2, 3, 7 or 8\n\nAdditionally, indices or sublattices can be wrapped in not to exclude them (see not):\n\nsublats = not(:A)               # Any sublat different from :A\nsublats = not(:A, :B)           # Any sublat different from :A and :B\nindices = not(8)                # Any site index different from 8\nindices = not(1, 3:4)           # Any site index different from 1, 3 or 4\nindices = (not(3:4), 4:6)       # Any site different from 3 and 4, *or* equal to 4, 5 or 6\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.spectrum-Tuple{Any}","page":"Reference","title":"Quantica.spectrum","text":"spectrum(h; method = defaultmethod(h), transform = missing)\n\nCompute the spectrum of a 0D Hamiltonian h (or alternatively of the bounded unit cell of a finite dimensional h) using one of the following methods\n\nmethod                    diagonalization function\n--------------------------------------------------------------\nLinearAlgebraPackage()     LinearAlgebra.eigen!\nArpackPackage()            Arpack.eigs (must be `using Arpack`)\n\nThe option transform = ε -> f(ε) allows to transform eigenvalues by f in the returned spectrum (useful for performing shifts or other postprocessing).\n\nThe energies and eigenstates in the resulting s::Spectrum object can be accessed with energies(s) and states(s)\n\nSee also\n\n`energies`, `states`, `bandstructure`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.states-Tuple{Quantica.Bandstructure,Any}","page":"Reference","title":"Quantica.states","text":"states(bs::Bandstructure, i)\n\nReturn the states of each vertex of the i-th band in bs, in the form of a Matrix of size (nψ, nk), where nψ is the length of each state vector, and nk the number of vertices.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.states-Tuple{Quantica.Spectrum}","page":"Reference","title":"Quantica.states","text":"states(s::Spectrum)\n\nReturn the states of s as the columns of a Matrix\n\nSee also\n\n`spectrum`, `energies`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.sublat-Tuple{AbstractArray{#s36,1} where #s36<:(StaticArrays.SArray{Tuple{S},T,1,S} where T where S)}","page":"Reference","title":"Quantica.sublat","text":"sublat(sites...; name::Symbol)\nsublat(sites::Vector{<:SVector}; name::Symbol)\n\nCreate a Sublat{E,T,D} that adds a sublattice, of name name, with sites at positions sites in E dimensional space. Sites can be entered as tuples or SVectors.\n\nExamples\n\njulia> sublat((0.0, 0), (1, 1), (1, -1), name = :A)\nSublat{2,Float64} : sublattice of Float64-typed sites in 2D space\n  Sites    : 3\n  Name     : :A\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.supercell-Tuple","page":"Reference","title":"Quantica.supercell","text":"supercell(lat::AbstractLattice{E,L}, v::NTuple{L,Integer}...; seed = missing, kw...)\nsupercell(lat::AbstractLattice{E,L}, sc::SMatrix{L,L´,Int}; seed = missing, kw...)\n\nGenerates a Superlattice from an L-dimensional lattice lat with Bravais vectors br´= br * sc, where sc::SMatrix{L,L´,Int} is the integer supercell matrix with the L´ vectors vs as columns. If no v are given, the superlattice will be bounded.\n\nOnly sites selected by siteselector(; kw...) will be included in the supercell (see siteselector for details on the available keywords kw). The search for included sites will start from point seed::Union{Tuple,SVector}, or the origin if seed = missing. If no keyword region is given in kw, a Bravais unit cell perpendicular to the v axes will be selected for the L-L´ non-periodic directions.\n\nsupercell(lattice::AbstractLattice{E,L}, factor::Integer; kw...)\n\nCalls supercell with a uniformly scaled sc = SMatrix{L,L}(factor * I)\n\nsupercell(lattice::AbstractLattice, factors::Integer...; kw...)\n\nCalls supercell with different scaling along each Bravais vector (diagonal supercell with factors along the diagonal)\n\nlat |> supercell(v...; kw...)\n\nCurried syntax, equivalent to `supercell(lat, v...; kw...)\n\nsupercell(h::Hamiltonian, v...; kw...)\n\nPromotes the Lattice of h to a Superlattice without changing the Hamiltonian itself, which always refers to the unitcell of the lattice.\n\nExamples\n\njulia> supercell(LatticePresets.honeycomb(), region = RegionPresets.circle(300))\nSuperlattice{2,2,Float64,0} : 2D lattice in 2D space, filling a 0D supercell\n  Bravais vectors : ((0.5, 0.866025), (-0.5, 0.866025))\n  Sublattices     : 2\n    Names         : (:A, :B)\n    Sites         : (1, 1) --> 2 total per unit cell\n  Supercell{2,0} for 0D superlattice of the base 2D lattice\n    Supervectors  : ()\n    Supersites    : 652966\n\njulia> supercell(LatticePresets.triangular(), (1,1), (1, -1))\nSuperlattice{2,2,Float64,2} : 2D lattice in 2D space, filling a 2D supercell\n  Bravais vectors : ((0.5, 0.866025), (-0.5, 0.866025))\n  Sublattices     : 1\n    Names         : (:A)\n    Sites         : (1) --> 1 total per unit cell\n  Supercell{2,2} for 2D superlattice of the base 2D lattice\n    Supervectors  : ((1, 1), (1, -1))\n    Supersites    : 2\n\njulia> LatticePresets.square() |> supercell(3)\nSuperlattice{2,2,Float64,2} : 2D lattice in 2D space, filling a 2D supercell\n  Bravais vectors : ((1.0, 0.0), (0.0, 1.0))\n  Sublattices     : 1\n    Names         : (:A)\n    Sites         : (1) --> 1 total per unit cell\n  Supercell{2,2} for 2D superlattice of the base 2D lattice\n    Supervectors  : ((3, 0), (0, 3))\n    Supersites    : 9\n\nSee also:\n\n`unitcell`, `siteselector`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.transform!-Tuple{Any,Quantica.Bandstructure}","page":"Reference","title":"Quantica.transform!","text":"transform!(f::Function, b::Bandstructure)\n\nTransform the energies of all bands in b by applying f to them in place.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.transform!-Tuple{Any,Quantica.Hamiltonian}","page":"Reference","title":"Quantica.transform!","text":"transform!(f::Function, h::Hamiltonian)\n\nTransform the site positions of the Hamiltonian's lattice in place without modifying the Hamiltonian harmonics.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.transform!-Tuple{Any,Quantica.Spectrum}","page":"Reference","title":"Quantica.transform!","text":"transform!(f::Function, s::Spectrum)\n\nTransform the energies of s by applying f to them in place.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.transform!-Tuple{Function,Quantica.Lattice}","page":"Reference","title":"Quantica.transform!","text":"transform!(f::Function, lat::Lattice)\n\nTransform the site positions of lat by applying f to them in place.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.unitcell-Tuple{Vararg{Union{Integer, Tuple, StaticArrays.SArray{Tuple{S},T,1,S} where T where S, StaticArrays.SArray{Tuple{S1,S2},T,2,L} where L where T where S2 where S1},N} where N}","page":"Reference","title":"Quantica.unitcell","text":"unitcell(lat::Lattice{E,L}, v::NTuple{L,Integer}...; seed = missing, kw...)\nunitcell(lat::Lattice{E,L}, uc::SMatrix{L,L´,Int}; seed = missing, kw...)\n\nGenerates a Lattice from an L-dimensional lattice lat and a larger unit cell, such that its Bravais vectors are br´= br * uc. Here uc::SMatrix{L,L´,Int} is the integer unitcell matrix, with the L´ vectors vs as columns. If no v are given, the new lattice will be bounded.\n\nOnly sites selected by siteselector(; kw...) will be included in the supercell (see siteselector for details on the available keywords kw). The search for included sites will start from point seed::Union{Tuple,SVector}, or the origin if seed = missing. If no keyword region is given in kw, a Bravais unit cell perpendicular to the v axes will be selected for the L-L´ non-periodic directions.\n\nunitcell(lattice::Lattice{E,L}, factor::Integer; kw...)\n\nCalls unitcell with a uniformly scaled uc = SMatrix{L,L}(factor * I)\n\nunitcell(lattice::Lattice{E,L}, factors::Integer...; kw...)\n\nCalls unitcell with different scaling along each Bravais vector (diagonal supercell with factors along the diagonal)\n\nunitcell(slat::Superlattice)\n\nConvert Superlattice slat into a lattice with its unit cell matching slat's supercell.\n\nunitcell(h::Hamiltonian, v...; modifiers = (), kw...)\n\nTransforms the Lattice of h to have a larger unitcell, while expanding the Hamiltonian accordingly. The modifiers (a tuple of ElementModifiers, either @onsite! or @hopping! with no free parameters) will be applied to onsite and hoppings as the hamiltonian is expanded. See @onsite! and @hopping! for details\n\nNote: for performance reasons, in sparse hamiltonians only the stored onsites and hoppings will be transformed by ElementModifiers, so you might want to add zero onsites or hoppings when building h to have a modifier applied to them later. Note also that additional onsites and hoppings may be stored when calling optimize! or bloch/bloch! on h for the first time.\n\nlat_or_h |> unitcell(v...; kw...)\n\nCurried syntax, equivalent to `unitcell(latorh, v...; kw...)\n\nExamples\n\njulia> unitcell(LatticePresets.honeycomb(), region = RegionPresets.circle(300))\nLattice{2,0,Float64} : 0D lattice in 2D space\n  Bravais vectors : ()\n  Sublattices     : 2\n    Names         : (:A, :B)\n    Sites         : (326483, 326483) --> 652966 total per unit cell\n\njulia> unitcell(LatticePresets.triangular(), (1,1), (1, -1))\nLattice{2,2,Float64} : 2D lattice in 2D space\n  Bravais vectors : ((0.0, 1.732051), (1.0, 0.0))\n  Sublattices     : 1\n    Names         : (:A)\n    Sites         : (2) --> 2 total per unit cell\n\njulia> LatticePresets.square() |> unitcell(3)\nLattice{2,2,Float64} : 2D lattice in 2D space\n  Bravais vectors : ((3.0, 0.0), (0.0, 3.0))\n  Sublattices     : 1\n    Names         : (:A)\n    Sites         : (9) --> 9 total per unit cell\n\njulia> supercell(LatticePresets.square(), 3) |> unitcell\nLattice{2,2,Float64} : 2D lattice in 2D space\n  Bravais vectors : ((3.0, 0.0), (0.0, 3.0))\n  Sublattices     : 1\n    Names         : (:A)\n    Sites         : (9) --> 9 total per unit cell\n\nSee also:\n\n`supercell`, `siteselector`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.vertices-Tuple{Quantica.Bandstructure,Any}","page":"Reference","title":"Quantica.vertices","text":"vertices(bs::Bandstructure, i)\n\nReturn the vertices (k..., ϵ) of the i-th band in bs, in the form of a Vector{SVector{L+1}}, where L is the lattice dimension.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.wrap-Tuple{Quantica.Hamiltonian,Int64}","page":"Reference","title":"Quantica.wrap","text":"wrap(h::Hamiltonian, axes; phases = missing)\n\nBuild a new Hamiltonian from h reducing its dimensions from L to L - length(axes) by wrapping the specified Bravais axes into a loop. axes can be an integer ∈ 1:L or a tuple of such integers. If phases are given (with length(axes) == length(phases)), the wrapped hoppings at a cell distance dn along axes will be multiplied by a factor cis(-dot(phases, dn)). This is useful, for example, to represent a flux Φ through a loop, using a single axes = 1 and phases = 2π * Φ/Φ₀.\n\nwrap(h::Hamiltonian; kw...)\n\nWrap all axes of h, yielding a compactified zero-dimensional Hamiltonian.\n\nh |> wrap(axes; kw...)\n\nCurried form equivalent to wrap(h, axes; kw...).\n\nExamples\n\njulia> LatticePresets.honeycomb() |> hamiltonian(hopping(1, range = 1/√3)) |>\n       unitcell((1,-1), (10, 10)) |> wrap(2)\nHamiltonian{<:Lattice} : Hamiltonian on a 1D Lattice in 2D space\n  Bloch harmonics  : 3 (SparseMatrixCSC, sparse)\n  Harmonic size    : 40 × 40\n  Orbitals         : ((:a,), (:a,))\n  Element type     : scalar (Complex{Float64})\n  Onsites          : 0\n  Hoppings         : 120\n  Coordination     : 3.0\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.@hopping!-Tuple{Any,Any}","page":"Reference","title":"Quantica.@hopping!","text":"@hopping!(args -> body; kw...)\n\nCreate an ElementModifier, to be used with parametric, that applies f = args -> body to hoppings energies specified by kw (see hopping for details on possible kws). The form of args -> body may be (t; params...) -> ... or (t, r, dr; params...) -> ... if the modification is position (r, dr) dependent. Keyword arguments params are optional, and include any parameters that body depends on that the user may want to tune.\n\nNote: unlike onsite and hopping, ElementModifiers cannot be combined (i.e. you cannot do @onsite!(...) + @hopping!(...)). ElementModifiers are not model terms but transformations of an existing Hamiltonian that are meant to be applied sequentially (the order of application usually matters).\n\nSee also:\n\n`@onsite!`, `parametric`\n\n\n\n\n\n","category":"macro"},{"location":"reference/#Quantica.@onsite!-Tuple{Any,Any}","page":"Reference","title":"Quantica.@onsite!","text":"@onsite!(args -> body; kw...)\n\nCreate an ElementModifier, to be used with parametric, that applies f = args -> body to onsite energies specified by kw (see onsite for details  on possible kws). The form of args -> body may be (o; params...) -> ... or (o, r; params...) -> ... if the modification is position (r) dependent. Keyword arguments params are optional, and include any parameters that body depends on that the user may want to tune.\n\nNote: unlike onsite and hopping, ElementModifiers cannot be combined (i.e. you cannot do @onsite!(...) + @hopping!(...)). ElementModifiers are not model terms but transformations of an existing Hamiltonian that are meant to be applied sequentially (the order of application usually matters).\n\nSee also:\n\n`@hopping!`, `parametric`\n\n\n\n\n\n","category":"macro"},{"location":"#Quantica.jl","page":"Home","title":"Quantica.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Quantica.jl is a Julia package for building generic tight-binding models and computing various spectral and transport properties.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Important information\nThis package supersedes Elsa.jl, which will soon be deprecated.","category":"page"},{"location":"#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"tutorial.md\",\n    \"examples.md\",\n    \"reference.md\",\n]\nDepth = 1","category":"page"},{"location":"#Current-functionality","page":"Home","title":"Current functionality","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Build arbitrary lattices (periodic or bounded in any dimension and with any unit cell)\nDefine generic model Hamiltonians by applying a model onto a lattice\nUse models with arbitrary orbital structure, spatial dependence and coordination (e.g. normal/superconducting, spin-orbit coupling, etc.)\nDefine parametric Hamiltonians that efficiently implement external parameters dependencies\nEfficiently compute the Bloch Hamiltonian matrix at arbitrary wave vector\nCompute the band structure or spectrum of a Hamiltonian, using advanced meshing and co-diagonalization techniques to resolve degeneracies and extract subbands\nUse Order-N Kernel polynomial methods to compute spectral and transport properties efficiently","category":"page"},{"location":"","page":"Home","title":"Home","text":"tip: Funding\nThis work has been partly funded by the Spanish Ministry of Economy and Competitiveness under Grant Nos. FIS2015-65706-P, PCI2018-093026, and the CSIC Intramural Project 201760I086.","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"}]
}
