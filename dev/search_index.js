var documenterSearchIndex = {"docs":
[{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"CurrentModule = Quantica","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [Quantica]","category":"page"},{"location":"reference/#Quantica.Quantica","page":"Reference","title":"Quantica.Quantica","text":"Quantica.jl\n\n(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage) (Image: GitHub commits since last release)\n\nThe Quantica.jl package provides an expressive API to build arbitrary quantum systems on a discrete lattice, and to compute a number of their properties.\n\nSome current features\n\nBuild Hamiltonians on discrete lattices of arbitrary dimensions, using tight-binding models with arbitrary number of orbitals\nCompute band structures of periodic systems and extract individual bands by interpolation\nCompute electronic structures and expectation values using Kernel Polynomial methods\n\nExported API\n\nlattice, sublat, bravais: build lattices\ndims, sites: inspect lattices\nhopping, onsite: build tightbinding models\nhamiltonian: build a Hamiltonian from tightbinding model and a lattice\nparametric, @onsite!, @hopping!, parameters: build a parametric Hamiltonian\nsupercell, unitcell, flatten, wrap, transform!, combine: build derived lattices or Hamiltonians\nmarchingmesh, linearmesh: define a specification to build a bandstructure discretization mesh\nbandstructure, spectrum: compute the generalized bandstructure of a Hamiltonian or a ParametricHamiltonian\nbands, energies, states: inspect spectrum and bandstructure objects\nmomentaKPM, dosKPM, averageKPM, densityKPM, bandrangeKPM: Kernel Polynomial Method\n\nSome of this functionality require loading one or more third-party packages, which include the following:\n\nKPM: FFTW, ArnoldiMethod\nBandstructures: Arpack, ArnoldiMethod, KrylovKit\n\nThe user is told when this is needed. We do this to reduce dependencies and launch time with packages whose functionality is not essential for the use of Quantica.jl\n\nOther functions become available after loading specific third-party packages:\n\nMakie: enables plot(::Hamiltonian) and plot(::Bandstructure) (for 1D and 2D bandstructures)\nVegaLite: enables vlplot(::Hamiltonian) and vlplot(::Bandstructure) (for 1D bandstructures)\n\nFunding\n\nThis work has been partly funded by the Spanish Ministry of Economy and Competitiveness under Grant Nos. FIS2015-65706-P, PCI2018-093026, and the CSIC Intramural Project 201760I086.\n\n\n\n\n\n","category":"module"},{"location":"reference/#Quantica.BoxIterator","page":"Reference","title":"Quantica.BoxIterator","text":"BoxIterator(seed::SVector{N,Int}; maxiterations = missing)\n\nCartesian iterator iter over SVector{N,Int}s (cells) that starts at seed and grows outwards in the form of a box of increasing sides (not necesarily equal) until it encompasses a certain N-dimensional region. To signal that a cell is in the desired region the user calls acceptcell!(iter, cell).\n\n\n\n\n\n","category":"type"},{"location":"reference/#Quantica.MeshSpec","page":"Reference","title":"Quantica.MeshSpec","text":"MeshSpec\n\nParent type of mesh specifications, which are currently MarchingMeshSpec (constructed with marchingmesh) and LinearMeshSpec (constructed with linearmesh).\n\nSee also\n\n`marchingmesh`, `linearmesh`, `buildmesh`\n\n\n\n\n\n","category":"type"},{"location":"reference/#Base.:&-Tuple{Quantica.Hamiltonian{#s38,L,M,A,H,O} where O<:Tuple{Vararg{Tuple{Vararg{Symbol,N} where N},N} where N} where H<:Quantica.HamiltonianHarmonic{L,M,A} where A<:(AbstractArray{T,2} where T) where M where L where #s38<:Quantica.Superlattice,Quantica.Hamiltonian{#s37,L,M,A,H,O} where O<:Tuple{Vararg{Tuple{Vararg{Symbol,N} where N},N} where N} where H<:Quantica.HamiltonianHarmonic{L,M,A} where A<:(AbstractArray{T,2} where T) where M where L where #s37<:Quantica.Superlattice}","page":"Reference","title":"Base.:&","text":"&(h1::Hamiltonian{<:Superlattice}, h2::Hamiltonian{<:Superlattice})\n\nConstruct a new Hamiltonian{<:Superlattice} using an and boolean mask, i.e. with a supercell that contains cells that are both in the supercell of h1 and h2\n\n&(s1::Superlattice, s2::Superlattice}\n\nEquivalent of the above for Superlattices\n\nSee also:\n\n`|`, `xor`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.:|-Tuple{Quantica.Hamiltonian{#s38,L,M,A,H,O} where O<:Tuple{Vararg{Tuple{Vararg{Symbol,N} where N},N} where N} where H<:Quantica.HamiltonianHarmonic{L,M,A} where A<:(AbstractArray{T,2} where T) where M where L where #s38<:Quantica.Superlattice,Quantica.Hamiltonian{#s37,L,M,A,H,O} where O<:Tuple{Vararg{Tuple{Vararg{Symbol,N} where N},N} where N} where H<:Quantica.HamiltonianHarmonic{L,M,A} where A<:(AbstractArray{T,2} where T) where M where L where #s37<:Quantica.Superlattice}","page":"Reference","title":"Base.:|","text":"|(h1::Hamiltonian{<:Superlattice}, h2::Hamiltonian{<:Superlattice})\n\nConstruct a new Hamiltonian{<:Superlattice} using an or boolean mask, i.e. with a supercell that contains cells that are either in the supercell of h1 or h2\n\n|(s1::Superlattice, s2::Superlattice}\n\nEquivalent of the above for Superlattices\n\nSee also:\n\n`&`, `xor`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.factorial-Union{Tuple{T}, Tuple{T,T}} where T<:Integer","page":"Reference","title":"Base.factorial","text":"factorial(n, k)\n\nCompute nk.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.xor-Tuple{Quantica.Hamiltonian{#s38,L,M,A,H,O} where O<:Tuple{Vararg{Tuple{Vararg{Symbol,N} where N},N} where N} where H<:Quantica.HamiltonianHarmonic{L,M,A} where A<:(AbstractArray{T,2} where T) where M where L where #s38<:Quantica.Superlattice,Quantica.Hamiltonian{#s37,L,M,A,H,O} where O<:Tuple{Vararg{Tuple{Vararg{Symbol,N} where N},N} where N} where H<:Quantica.HamiltonianHarmonic{L,M,A} where A<:(AbstractArray{T,2} where T) where M where L where #s37<:Quantica.Superlattice}","page":"Reference","title":"Base.xor","text":"xor(h1::Hamiltonian{<:Superlattice}, h2::Hamiltonian{<:Superlattice})\n\nConstruct a new Hamiltonian{<:Superlattice} using a xor boolean mask, i.e. with a supercell that contains cells that are either in the supercell of h1 or h2 but not in both\n\nxor(s1::Superlattice, s2::Superlattice}\n\nEquivalent of the above for Superlattices\n\nSee also:\n\n`&`, `|`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.averageKPM-Tuple{Any,Any}","page":"Reference","title":"Quantica.averageKPM","text":"averageKPM(h::AbstractMatrix, A; kBT = 0, Ef = 0, kw...)\n\nCompute, using the Kernel Polynomial Method (KPM), the thermal expectation value <A> = Σ_k f(E_k) <k|A|k> =  ∫dE f(E) Tr [A δ(E-H)] = Tr [A f(H)] for a given hermitian operator A and a hamiltonian h (see momentaKPM and its options kw for further details). f(E) is the Fermi-Dirac distribution function, kBT is the temperature in energy units and Ef the Fermi energy.\n\naverageKPM(μ::MomentaKPM, A; kBT = 0, Ef = 0)\n\nSame as above with the KPM momenta as input (see momentaKPM).\n\naverageKPM(h::Hamiltonian, A::Hamiltonian; kw...)\n\nEquivalent to averageKPM(bloch(h), bloch(A); kw...) for finite Hamiltonians (zero dimensional).\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.bands-Tuple{Quantica.Bandstructure}","page":"Reference","title":"Quantica.bands","text":"bands(bs::Bandstructure)\n\nReturn a vector of all the Bands in bs.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.bandstructure-Tuple{Quantica.Hamiltonian}","page":"Reference","title":"Quantica.bandstructure","text":"bandstructure(h::Hamiltonian; points = 13, kw...)\n\nCompute the bandstructure of h on a mesh over h's full Brillouin zone, with points points along each axis, spanning the interval [-π,π] along each reciprocal axis.\n\nbandstructure(h::Hamiltonian, spec::MeshSpec; lift = missing, kw...)\n\nCall bandstructure(h, mesh; lift = lift, kw...) with mesh = buildmesh(spec, h) and lift = buildlift(spec, h) if not provided. See MeshSpec for available mesh specs. If the lift = missing and the dimensions of the mesh do not match the Hamiltonian's, a lift function is used that lifts the mesh onto the dimensions h by appending vertex coordinates with zeros.\n\nbandstructure(h::Hamiltonian, mesh::Mesh; lift = missing, kw...)\n\nCompute the bandstructure bandstructure(h, mesh; kw...) of Bloch Hamiltonian bloch(h, ϕ), with ϕ = v taken on each vertex v of mesh (or ϕ = lift(v...) if a lift function is provided).\n\nbandstructure(ph::ParametricHamiltonian, ...; kw...)\n\nCompute the bandstructure of a ph with i parameters (see parameters(ph)), where mesh is interpreted as a discretization of parameter space ⊗ Brillouin zone, so that each vertex reads v = (p₁,..., pᵢ, ϕ₁,..., ϕⱼ), with p the values assigned to parameters(ph) and ϕᵢ the Bloch phases.\n\nbandstructure(matrixf::Function, mesh::Mesh; kw...)\n\nCompute the bandstructure of the Hamiltonian matrix m = matrixf(ϕ), with ϕ evaluated on the vertices v of the mesh. Note that ϕ in matrixf(ϕ) is an unsplatted container. Hence, i.e. matrixf(x) = ... or matrixf(x, y) = ... will not work, use matrixf((x,)) = ... or matrixf((x, y)) = ... instead.\n\nOptions\n\nThe default options are\n\n(lift = missing, minprojection = 0.5, method = defaultmethod(h), transform = missing)\n\nlift: when not missing, lift is a function lift = (vs...) -> ϕ, where vs are the coordinates of a mesh vertex and ϕ are Bloch phases if sampling a h::Hamiltonian, or (paramsⱼ..., ϕᵢ...) if sampling a ph::ParametricHamiltonian, and params are values for parameters(ph). It represents a mapping from a mesh and a Brillouin/parameter space. This allows to compute a bandstructure along a cut in the Brillouin zone/parameter space, see below for examples.\n\nminprojection: determines the minimum projection between eigenstates to connect them into a common subband.\n\nmethod: it is chosen automatically if unspecified, and can be one of the following\n\nmethod                     diagonalization function\n--------------------------------------------------------------\nLinearAlgebraPackage()     LinearAlgebra.eigen!\nArpackPackage()            Arpack.eigs (must be `using Arpack`)\n\nOptions passed to the method will be forwarded to the diagonalization function. For example, method = ArpackPackage(nev = 8, sigma = 1im) will use Arpack.eigs(matrix; nev = 8, sigma = 1im) to compute the bandstructure.\n\ntransform: the option transform = ε -> f(ε) allows to transform eigenvalues by f in the returned bandstructure (useful for performing shifts or other postprocessing).\n\nExamples\n\njulia> h = LatticePresets.honeycomb() |> hamiltonian(hopping(-1, range = 1/√3)) |> unitcell(3);\n\njulia> bandstructure(h; points = 25, method = LinearAlgebraPackage())\nBandstructure{2}: collection of 2D bands\n  Bands        : 8\n  Element type : scalar (Complex{Float64})\n  Mesh{2}: mesh of a 2-dimensional manifold\n    Vertices   : 625\n    Edges      : 1776\n\njulia> bandstructure(h, linearmesh(:Γ, :X, :Y, :Γ))\nBandstructure{1}: collection of 1D bands\n  Bands        : 17\n  Element type : scalar (Complex{Float64})\n  Mesh{1}: mesh of a 1-dimensional manifold\n    Vertices   : 37\n    Edges      : 36\n\njulia> bandstructure(h, marchingmesh((0, 2π); points = 25); lift = φ -> (φ, 0))\n       # Equivalent to bandstructure(h, linearmesh(:Γ, :X; points = 11))\nBandstructure{1}: collection of 1D bands\n  Bands        : 18\n  Element type : scalar (Complex{Float64})\n  Mesh{1}: mesh of a 1-dimensional manifold\n    Vertices   : 25\n    Edges      : 24\n\nSee also\n\n`marchingmesh`, `linearmesh`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.bloch","page":"Reference","title":"Quantica.bloch","text":"bloch(h::Hamiltonian{<:Lattice}, ϕs)\n\nBuild the Bloch Hamiltonian matrix of h, for Bloch phases ϕs = (ϕ₁, ϕ₂,...) (or an SVector(ϕs...)). In terms of Bloch wavevector k, ϕs = k * bravais(h), it is defined as H(ϕs) = ∑exp(-im * ϕs' * dn) h_dn where h_dn are Bloch harmonics connecting unit cells at a distance dR = bravais(h) * dn.\n\nbloch(h::Hamiltonian{<:Lattice})\n\nBuild the intra-cell Hamiltonian matrix of h, without adding any Bloch harmonics.\n\nbloch(h::Hamiltonian{<:Lattice}, ϕs, axis::Int)\n\nA nonzero axis produces the derivative of the Bloch matrix respect to ϕs[axis] (i.e. the velocity operator along this axis), ∂H(ϕs) = ∑ -im * dn[axis] * exp(-im * ϕs' * dn) h_dn\n\nbloch(matrix, h::Hamiltonian{<:Lattice}, ϕs::NTuple{L,Real}, dnfunc::Function)\n\nGeneralization that applies a prefactor dnfunc(dn) * exp(im * ϕs' * dn) to the dn harmonic.\n\nbloch(ph::ParametricHamiltonian, pϕs, [axis])\n\nSame as above, but with pϕs = (p₁,...,pᵢ, ϕ₁, ..., ϕⱼ), with p values for parameters(ph) and ϕ Bloch phases.\n\nh |> bloch(ϕs, ...)\n\nFunctional forms of bloch, equivalent to bloch(h, ϕs, ...)\n\nNotes\n\nbloch allocates a new matrix on each call. For a non-allocating version of bloch, see bloch!.\n\nExamples\n\njulia> h = LatticePresets.honeycomb() |> hamiltonian(onsite(1) + hopping(2)) |> bloch((0, 0))\n2×2 SparseMatrixCSC{Complex{Float64},Int64} with 4 stored entries:\n  [1, 1]  =  13.0+0.0im\n  [2, 1]  =  6.0+0.0im\n  [1, 2]  =  6.0+0.0im\n  [2, 2]  =  13.0+0.0im\n\nSee also:\n\n`bloch!`, `optimize!`, `similarmatrix`\n\n\n\n\n\n","category":"function"},{"location":"reference/#Quantica.bloch!","page":"Reference","title":"Quantica.bloch!","text":"bloch!(matrix, h::Hamiltonian, ϕs, [axis])\n\nIn-place version of bloch. Overwrite matrix with the Bloch Hamiltonian matrix of h for the specified Bloch phases ϕs = (ϕ₁,ϕ₂,...) (see bloch for definition and API).  A conventient way to obtain a matrix is to use similarmatrix(h,...), which will return an AbstractMatrix of the same type as the Hamiltonian's. Note, however, that matrix need not be of the same type (e.g. it can be dense with Number eltype for a sparse h with SMatrix block eltype).\n\nbloch!(matrix, ph::ParametricHamiltonian, pϕs, [axis])\n\nSame as above, but with pϕs = (p₁,...,pᵢ, ϕ₁, ..., ϕⱼ), with p values for parameters(ph) and ϕ Bloch phases.\n\nExamples\n\njulia> h = LatticePresets.honeycomb() |> hamiltonian(hopping(2I), orbitals = (Val(2), Val(1)));\n\njulia> bloch!(similarmatrix(h), h, (0, 0))\n2×2 SparseMatrixCSC{StaticArrays.SArray{Tuple{2,2},Complex{Float64},2,4},Int64} with 4 stored entries:\n  [1, 1]  =  [12.0+0.0im 0.0+0.0im; 0.0+0.0im 12.0+0.0im]\n  [2, 1]  =  [6.0+0.0im 0.0+0.0im; 0.0+0.0im 0.0+0.0im]\n  [1, 2]  =  [6.0+0.0im 0.0+0.0im; 0.0+0.0im 0.0+0.0im]\n  [2, 2]  =  [12.0+0.0im 0.0+0.0im; 0.0+0.0im 0.0+0.0im]\n\njulia> bloch!(similarmatrix(h, AbstractMatrix{ComplexF64}), h, (0, 0))\n3×3 SparseMatrixCSC{Complex{Float64},Int64} with 9 stored entries:\n  [1, 1]  =  12.0+0.0im\n  [2, 1]  =  0.0+0.0im\n  [3, 1]  =  6.0+0.0im\n  [1, 2]  =  0.0+0.0im\n  [2, 2]  =  12.0+0.0im\n  [3, 2]  =  0.0+0.0im\n  [1, 3]  =  6.0+0.0im\n  [2, 3]  =  0.0+0.0im\n  [3, 3]  =  12.0+0.0im\n\njulia> ph = parametric(h, @hopping!((t; α) -> α * t));\n\njulia> bloch!(similarmatrix(ph, AbstractMatrix{ComplexF64}), ph, (2, 0, 0))\n3×3 SparseMatrixCSC{Complex{Float64},Int64} with 9 stored entries:\n  [1, 1]  =  24.0+0.0im\n  [2, 1]  =  0.0+0.0im\n  [3, 1]  =  12.0+0.0im\n  [1, 2]  =  0.0+0.0im\n  [2, 2]  =  24.0+0.0im\n  [3, 2]  =  0.0+0.0im\n  [1, 3]  =  12.0+0.0im\n  [2, 3]  =  0.0+0.0im\n  [3, 3]  =  24.0+0.0im\n\nSee also:\n\n`bloch`, `optimize!`, `similarmatrix`\n\n\n\n\n\n","category":"function"},{"location":"reference/#Quantica.bravais-Tuple{Vararg{Union{Tuple, AbstractArray{T,1} where T, AbstractArray{T,2} where T},N} where N}","page":"Reference","title":"Quantica.bravais","text":"bravais(vecs...; semibounded = false)\nbravais(matrix; semibounded = false)\n\nCreate a Bravais{E,L} that adds L Bravais vectors vecs in E dimensional space, alternatively given as the columns of matrix mat. For higher instantiation efficiency enter vecs as Tuples or SVectors and mat as SMatrix.\n\nTo create semibounded lattices along some or all Bravais vectors, use semibounded. A semibounded = true makes all axes semibounded. A semibounded = (axes::Int...) indicates the indices of axes to be made semibounded. A tuple of Booleans, one per Bravais axes, semibounded = issemi::NTuple{L,Bool} is also allowed. Note that semibounded lattices always extend toward positive multiples of Bravais vectors. To invert the direction, invert the vectors.\n\nWe can scale a b::Bravais simply by multiplying it with a factor a, like a * b.\n\nbravais(lat::Lattice)\nbravais(h::Hamiltonian)\n\nObtain the Bravais matrix of lattice lat or Hamiltonian h\n\nExamples\n\njulia> bravais((1.0, 2), (3, 4))\nBravais{2,2,Float64} : set of 2 Bravais vectors in 2D space.\n  Vectors     : ((1.0, 2.0), (3.0, 4.0))\n  Matrix      : [1.0 3.0; 2.0 4.0],\n  Semibounded : none\n\nSee also:\n\n`semibounded`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.buildlift-Tuple{Quantica.MeshSpec,Union{Quantica.Hamiltonian, Quantica.ParametricHamiltonian}}","page":"Reference","title":"Quantica.buildlift","text":"buildlift(s::MeshSpec{L}, h::Union{Hamiltonian,ParametricHamiltonian})\n\nBuild a lift function that maps a Mesh built with buildmesh(s, h) to the Brillouin/parameter space of h (see bandstructure for details).\n\nSee also\n\n`buildmesh`, `marchingmesh`, `linearmesh`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.buildmesh-Tuple{Quantica.MeshSpec,Union{Quantica.Hamiltonian, Quantica.ParametricHamiltonian}}","page":"Reference","title":"Quantica.buildmesh","text":"buildmesh(s::MeshSpec, h::Union{Hamiltonian,ParametricHamiltonian})\n\nBuild a Mesh from the spec s, using properties of h as needed. The use of h depends on the spec. For a LinearMeshSpec with samelength = false, the Bravais matrix of h is needed to work out the length of each mesh segment in the Brillouin zone, while for other specs such as MarchingMeshSpec, h is not needed and may be omitted (see example).\n\nExamples\n\njulia> buildmesh(marchingmesh((-π, π), (0, 2π), points = 10))\nMesh{2}: mesh of a 2-dimensional manifold\n  Vertices   : 100\n  Edges      : 261\n\nSee also\n\n`buildlift`, `marchingmesh`, `linearmesh`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.combine-Tuple{Vararg{Quantica.Hamiltonian,N} where N}","page":"Reference","title":"Quantica.combine","text":"combine(hams::Hamiltonian...; coupling = missing)\n\nBuild a new Hamiltonian h that combines all hams as diagonal blocks, and applies coupling::Model, if provided, to build the off-diagonal couplings. Note that the diagonal blocks are not modified by the coupling model.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.combine-Tuple{Vararg{Quantica.Lattice,N} where N}","page":"Reference","title":"Quantica.combine","text":"combine(lats::Lattice...)\n\nIf all lats have compatible Bravais vectors, combine them into a single lattice. Sublattice names are renamed to be unique if necessary.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.densityKPM-Tuple{Any,Any}","page":"Reference","title":"Quantica.densityKPM","text":"densityKPM(h::AbstractMatrix, A; resolution = 2, kw...)\n\nCompute, using the Kernel Polynomial Method (KPM), the local spectral density of an operator A ρ_A(ϵ) = ⟨ket|A δ(ϵ-h)|ket⟩/⟨ket|ket⟩ for a given ket::AbstractVector and hamiltonian h, or the global spectral density ρ_A(ϵ) = Tr[A δ(ϵ-h)] if ket is missing. If ket is an AbstractMatrix it evaluates the trace over the set of kets in ket (see momentaKPM and its options kw for further details). A tuple of energy points xk and ρ_A values is returned where the number of energy points xk is order * resolution, rounded to the closest integer.\n\ndensityKPM(momenta::MomentaKPM; resolution = 2)\n\nSame as above with the KPM momenta as input (see momentaKPM).\n\ndensityKPM(h::Hamiltonian, A::Hamiltonian; kw...)\n\nEquivalent to densityKPM(bloch(h), bloch(A); kw...) for finite Hamiltonians (zero dimensional).\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.dims-Union{Tuple{Quantica.Lattice{E,L,T,B,U} where U<:(Quantica.Unitcell{E,T,N} where N) where B<:(Quantica.Bravais{E,L,T,EL} where EL) where T<:AbstractFloat}, Tuple{L}, Tuple{E}} where L where E","page":"Reference","title":"Quantica.dims","text":"dims(lat::Lattice{E,L}) -> (E, L)\n\nReturn a tuple (E, L) of the embedding and lattice dimensions of lat\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.dosKPM-Tuple{Any}","page":"Reference","title":"Quantica.dosKPM","text":"dosKPM(h::AbstractMatrix; resolution = 2, kw...)\n\nCompute, using the Kernel Polynomial Method (KPM), the local density of states ρ(ϵ) = ⟨ket|δ(ϵ-h)|ket⟩/⟨ket|ket⟩ for a given ket::AbstractVector and hamiltonian h, or the global density of states ρ(ϵ) = Tr[δ(ϵ-h)] if ket is missing.\n\nIf ket is an AbstractMatrix it evaluates the trace over the set of kets in ket (see momentaKPM and its options kw for further details). The result is a tuple of energy points xk::Vector and real ρ::Vector values (any imaginary part in ρ is dropped), where the number of energy points xk is order * resolution, rounded to the closest integer.\n\ndosKPM(μ::MomentaKPM; resolution = 2)\n\nSame as above with momenta μ as input.\n\ndosKPM(h::Hamiltonian; kw...)\n\nEquivalent to dosKPM(bloch(h); kw...) for finite hamiltonians (zero dimensional).\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.energies-Tuple{Quantica.Spectrum}","page":"Reference","title":"Quantica.energies","text":"energies(s::Spectrum)\n\nReturn the energies of s as a Vector\n\nSee also\n\n`spectrum`, `states`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.flatten-Tuple{}","page":"Reference","title":"Quantica.flatten","text":"flatten(h::Hamiltonian)\n\nFlatten a multiorbital Hamiltonian h into one with a single orbital per site. The associated lattice is flattened also, so that there is one site per orbital for each initial site (all at the same position). Note that in the case of sparse Hamiltonians, zeros in hopping/onsite matrices are preserved as structural zeros upon flattening.\n\nh |> flatten()\n\nFunctional form equivalent to flatten(h) of h |> flatten (included for consistency with the rest of the API).\n\nExamples\n\njulia> h = LatticePresets.honeycomb() |>\n           hamiltonian(hopping(@SMatrix[1; 2], range = 1/√3, sublats = :A =>:B),\n           orbitals = (Val(1), Val(2)))\nHamiltonian{<:Lattice} : Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 3 (SparseMatrixCSC, sparse)\n  Harmonic size    : 2 × 2\n  Orbitals         : ((:a,), (:a, :a))\n  Element type     : 2 × 2 blocks (Complex{Float64})\n  Onsites          : 0\n  Hoppings         : 3\n  Coordination     : 1.5\n\njulia> flatten(h)\nHamiltonian{<:Lattice} : Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 3 (SparseMatrixCSC, sparse)\n  Harmonic size    : 3 × 3\n  Orbitals         : ((:flat,), (:flat,))\n  Element type     : scalar (Complex{Float64})\n  Onsites          : 0\n  Hoppings         : 6\n  Coordination     : 2.0\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.hamiltonian-Tuple{Any,Vararg{Any,N} where N}","page":"Reference","title":"Quantica.hamiltonian","text":"hamiltonian(lat, model; orbitals, type)\n\nCreate a Hamiltonian by applying model::TighbindingModel to the lattice lat (see hopping and onsite for details on building tightbinding models).\n\nThe number of orbitals on each sublattice can be specified by the keyword orbitals (otherwise all sublattices have one orbital by default). The following, and obvious combinations, are possible formats for the orbitals keyword:\n\norbitals = :a                # all sublattices have 1 orbital named :a\norbitals = (:a,)             # same as above\norbitals = (:a, :b, 3)       # all sublattices have 3 orbitals named :a and :b and :3\norbitals = ((:a, :b), (:c,)) # first sublattice has 2 orbitals, second has one\norbitals = ((:a, :b), :c)    # same as above\norbitals = (Val(2), Val(1))  # same as above, with automatic names\norbitals = (:A => (:a, :b), :D => :c) # sublattice :A has two orbitals, :D and rest have one\norbitals = :D => Val(4)      # sublattice :D has four orbitals, rest have one\n\nThe matrix sizes of tightbinding model must match the orbitals specified. Internally, we define a block size N = max(num_orbitals). If N = 1 (all sublattices with one orbital) the the Hamiltonian element type is type. Otherwise it is SMatrix{N,N,type} blocks, padded with the necessary zeros as required. Keyword type is Complex{T} by default, where T is the number type of lat.\n\nlat |> hamiltonian(model; kw...)\n\nFunctional hamiltonian form equivalent to hamiltonian(lat, model[, funcmodel]; kw...).\n\nIndexing\n\nIndexing into a Hamiltonian h works as follows. Access the HamiltonianHarmonic matrix at a given dn::NTuple{L,Int} with h[dn]. Assign v into element (i,j) of said matrix with h[dn][i,j] = v or h[dn, i, j] = v. Broadcasting with vectors of indices is and js is supported, h[dn][is, js] = v_matrix.\n\nTo add an empty harmonic with a given dn::NTuple{L,Int}, do push!(h, dn). To delete it, do deleteat!(h, dn).\n\nExamples\n\njulia> h = hamiltonian(LatticePresets.honeycomb(), hopping(@SMatrix[1 2; 3 4], range = 1/√3), orbitals = Val(2))\nHamiltonian{<:Lattice} : Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 5 (SparseMatrixCSC, sparse)\n  Harmonic size    : 2 × 2\n  Orbitals         : ((:a, :a), (:a, :a))\n  Element type     : 2 × 2 blocks (Complex{Float64})\n  Onsites          : 0\n  Hoppings         : 6\n  Coordination     : 3.0\n\njulia> push!(h, (3,3)) # Adding a new Hamiltonian harmonic (if not already present)\nHamiltonian{<:Lattice} : Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 6 (SparseMatrixCSC, sparse)\n  Harmonic size    : 2 × 2\n  Orbitals         : ((:a, :a), (:a, :a))\n  Element type     : 2 × 2 blocks (Complex{Float64})\n  Onsites          : 0\n  Hoppings         : 6\n  Coordination     : 3.0\n\njulia> h[(3,3)][1,1] = @SMatrix[1 2; 2 1]; h[(3,3)] # element assignment\n2×2 SparseMatrixCSC{StaticArrays.SArray{Tuple{2,2},Complex{Float64},2,4},Int64} with 1 stored entry:\n  [1, 1]  =  [1.0+0.0im 2.0+0.0im; 2.0+0.0im 1.0+0.0im]\n\njulia> h[(3,3)][[1,2],[1,2]] .= Ref(@SMatrix[1 2; 2 1])\n2×2 view(::SparseMatrixCSC{StaticArrays.SArray{Tuple{2,2},Complex{Float64},2,4},Int64}, [1, 2], [1, 2]) with eltype StaticArrays.SArray{Tuple{2,2},Complex{Float64},2,4}:\n [1.0+0.0im 2.0+0.0im; 2.0+0.0im 1.0+0.0im]  [1.0+0.0im 2.0+0.0im; 2.0+0.0im 1.0+0.0im]\n [1.0+0.0im 2.0+0.0im; 2.0+0.0im 1.0+0.0im]  [1.0+0.0im 2.0+0.0im; 2.0+0.0im 1.0+0.0im]\n\nSee also:\n\n`onsite`, `hopping`, `bloch`, `bloch!`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.hopping-Tuple{Any}","page":"Reference","title":"Quantica.hopping","text":"hopping(t; region = missing, sublats = missing, dn = missing, range = 1, plusadjoint = false)\n\nCreate an TightbindingModel with a single HoppingTerm that applies a hopping t to a Lattice when creating a Hamiltonian with hamiltonian.\n\nThe hopping amplitude t can be a number, a matrix (preferably SMatrix), a UniformScaling (e.g. 3*I) or a function of the form (r, dr) -> ... for a position-dependent hopping (r is the bond center, and dr the bond vector). If sublats is specified as a sublattice name pair, or tuple thereof, hopping is only applied between sublattices with said names.\n\nThe dimension of t::AbstractMatrix must match the orbital dimension of applicable sublattices (see also orbitals option for hamiltonian). If t::UniformScaling it will be converted to a (possibly rectangular) identity matrix of the appropriate size when applied to multiorbital sublattices. Similarly, if t::SMatrix it will be truncated or padded to the appropriate size.\n\nOnsiteTerms and HoppingTerms created with onsite or hopping can be added or substracted together to build more complicated TightbindingModels.\n\nhopping(model::TightbindingModel; kw...)\n\nReturn a TightbindingModel with only the hopping terms of model. Any non-missing kw is applied to all such terms.\n\nKeyword arguments\n\nOnly hoppings between two sites at positions r₁ = r - dr/2 and r₂ = r + dr, belonging to unit cells at integer distance dn´ and to sublattices s₁ and s₂ will be selected if: region(r, dr) && s in sublats && dn´ in dn && norm(dr) <= range. If any of these is missing it will not be used to constraint the selection. Note that the default range is 1, not missing.\n\nThe keyword dn can be a Tuple/Vector/SVector of Ints, or a tuple thereof. The keyword sublats allows the following formats:\n\nsublats = :A => :B                 # Hopping from :A to :B sublattices\nsublats = (:A => :B,)              # Same as above\nsublats = (:A => :B, :C => :D)     # Hopping from :A to :B or :C to :D\nsublats = (:A, :C) .=> (:B, :D)    # Broadcasted pairs, same as above\nsublats = (:A, :C) => (:B, :D)     # Direct product, (:A=>:B, :A=:D, :C=>:B, :C=>D)\n\nThe keyword plusadjoint produces a model with the input hopping term plus its adjoint. Note that this substitution is made before multiplying by any coefficient, so that im*hopping(..., plusadjoint = true) == im*(hopping(...) + hopping(...)').\n\nCombining models\n\nOnsiteTerms and HoppingTerms created with onsite or hopping can added or substracted together or be multiplied by scalars to build more complicated TightbindingModels, e.g. onsite(1) - 3 * hopping(2)\n\nExamples\n\njulia> model = 3 * onsite(1) - hopping(2, dn = ((1,2), (0,0)), sublats = :A=>:B)\nTightbindingModel{2}: model with 2 terms\n  OnsiteTerm{Int64}:\n    Sublattices      : any\n    Coefficient      : 3\n  HoppingTerm{Int64}:\n    Sublattice pairs : (:A => :B,)\n    dn cell distance : ([1, 2], [0, 0])\n    Hopping range    : 1.0\n    Coefficient      : -1\n\njulia> newmodel = onsite(model) + hopping(model, range = 2)\nTightbindingModel{2}: model with 2 terms\n  OnsiteTerm{Int64}:\n    Sublattices      : any\n    Coefficient      : 3\n  HoppingTerm{Int64}:\n    Sublattice pairs : (:A => :B,)\n    dn cell distance : ([1, 2], [0, 0])\n    Hopping range    : 2.0\n    Coefficient      : -1\n\njulia> LatticePresets.honeycomb() |> hamiltonian(hopping((r,dr) -> cos(r[1]), sublats = (:A,:B) => (:A,:B)))\nHamiltonian{<:Lattice} : Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 7 (SparseMatrixCSC, sparse)\n  Harmonic size    : 2 × 2\n  Orbitals         : ((:a,), (:a,))\n  Element type     : scalar (Complex{Float64})\n  Onsites          : 0\n  Hoppings         : 18\n  Coordination     : 9.0\n\nSee also:\n\n`onsite`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.lattice-Tuple{Quantica.Sublat,Vararg{Quantica.Sublat,N} where N}","page":"Reference","title":"Quantica.lattice","text":"lattice([bravais::Bravais,] sublats::Sublat...; dim::Val{E}, type::T, names)\n\nCreate a Lattice{E,L,T} with Bravais matrix bravais and sublattices sublats converted to a common  E-dimensional embedding space and type T. To override the embedding  dimension E, use keyword dim = Val(E). Similarly, override type T with type = T.\n\nThe keywords names can be used to rename sublats. Given names can be replaced to ensure that all sublattice names are unique.\n\nSee also LatticePresets for built-in lattices.\n\nExamples\n\njulia> lattice(bravais((1, 0)), sublat((0, 0)), sublat((0, Float32(1))); dim = Val(3))\nLattice{3,1,Float32} : 1D lattice in 3D space\n  Bravais vectors : ((1.0f0, 0.0f0, 0.0f0),)\n  Sublattices     : 2\n    Names         : (:A, :B)\n    Sites         : (1, 1) --> 2 total per unit cell\n\njulia> LatticePresets.honeycomb(semibounded = 1, names = (:C, :D))\nLattice{2,2,Float64} : 2D lattice in 2D space\n  Bravais vectors : ((0.5, 0.866025), (-0.5, 0.866025))\n    Semibounded   : (1)\n  Sublattices     : 2\n    Names         : (:C, :D)\n    Sites         : (1, 1) --> 2 total per unit cell\n\nSee also:\n\n`LatticePresets`, `bravais`, `sublat`, `supercell`, `intracell`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.linearmesh-Tuple","page":"Reference","title":"Quantica.linearmesh","text":"linearmesh(nodes...; points = 13, samelength = false, closed = false)\n\nCreate a MeshSpec for a one-dimensional Mesh connecting the nodes with straight segments, each containing a number points of points (endpoints included). If a different number of points for each of the N segments is required, use points::NTuple{N,Int}. If samelength each segment has equal length in mesh coordinates. If closed the last node is connected to the first node (must be equal)\n\nExamples\n\njulia> buildmesh(linearmesh(:Γ, :K, :M, :Γ; points = (101, 30, 30)), HamiltonianPresets.graphene())\nMesh{1}: mesh of a 1-dimensional manifold\n  Vertices   : 159\n  Edges      : 158\n\nSee also\n\n`marchingmesh`, `buildmesh`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.marchingmesh-Union{Tuple{Vararg{Tuple,L}}, Tuple{L}} where L","page":"Reference","title":"Quantica.marchingmesh","text":"marchingmesh(minmaxaxes...; axes = 1.0 * I, points = 13)\n\nCreate a MeshSpec for a L-dimensional marching-tetrahedra Mesh over a parallelepiped with axes given by the columns of axes. The points along axis i are distributed between first(minmaxaxes[i]) and last(minmaxaxes[i]). The number of points on each axis is given by points, or points[i] if several are given.\n\nExamples\n\njulia> buildmesh(marchingmesh((-π, π), (0,2π); points = 25))\nMesh{2}: mesh of a 2-dimensional manifold\n  Vertices   : 625\n  Edges      : 1776\n\njulia> buildmesh(marchingmesh((-π, π), (0,2π); points = (10,10)))\nMesh{2}: mesh of a 2-dimensional manifold\n  Vertices   : 100\n  Edges      : 261\n\nSee also\n\n`linearmesh`, `buildmesh`\n\nExternal links\n\nMarching tetrahedra (https://en.wikipedia.org/wiki/Marching_tetrahedra) in Wikipedia\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.momentaKPM","page":"Reference","title":"Quantica.momentaKPM","text":"momentaKPM(h::AbstractMatrix, A = I; ket = missing, order = 10, randomkets = 1, bandrange = missing)\n\nCompute the Kernel Polynomial Method (KPM) momenta μ_n = ⟨ket|T_n(h) A|ket⟩/⟨ket|ket⟩ where T_n(x) is the Chebyshev polynomial of order n, for a given ket::AbstractVector, hamiltonian h, and observable A. If ket is missing, momenta are computed by means of a stochastic trace μ_n = Tr[A T_n(h)] ≈ ∑ₐ⟨a|A T_n(h)|a⟩/N over N = randomkets normalized random |a⟩. Furthermore, the trace over a specific set of kets can also be computed; in this case ket::AbstractMatrix must be a matrix where the columns are the kets involved in the calculation.\n\nThe order of the Chebyshev expansion is order. The bandbrange = (ϵmin, ϵmax) should completely encompass the full bandwidth of hamiltonian. If missing it is computed automatically using ArnoldiMethods (must be loaded).\n\nExamples\n\njulia> h = LatticePresets.cubic() |> hamiltonian(hopping(1)) |> unitcell(region = RegionPresets.sphere(10));\n\njulia> momentaKPM(bloch(h), bandrange = (-6,6))\nQuantica.MomentaKPM{Float64}([0.9594929736144973, -0.005881595972403821, -0.4933354572913581, 0.00359537502632597, 0.09759451291347333, -0.0008081453185250322, -0.00896262538765363, 0.00048205637037715177, -0.0003705198310034668, 9.64901673962623e-20, 9.110915988898614e-18], (0.0, 6.030150753768845))\n\n\n\n\n\n","category":"function"},{"location":"reference/#Quantica.offdiagonal-Tuple{Quantica.TightbindingModel,Any,Any}","page":"Reference","title":"Quantica.offdiagonal","text":"offdiagonal(model, lat, nsublats::NTuple{N,Int})\n\nBuild a restricted version of model that applies only to off-diagonal blocks formed by sublattice groups of size nsublats.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.onsite-Tuple{Any}","page":"Reference","title":"Quantica.onsite","text":"onsite(o; region = missing, sublats = missing)\n\nCreate an TightbindingModel with a single OnsiteTerm that applies an onsite energy o to a Lattice when creating a Hamiltonian with hamiltonian.\n\nThe onsite energy o can be a number, a matrix (preferably SMatrix), a UniformScaling (e.g. 3*I) or a function of the form r -> ... for a position-dependent onsite energy.\n\nThe dimension of o::AbstractMatrix must match the orbital dimension of applicable sublattices (see also orbitals option for hamiltonian). If o::UniformScaling it will be converted to an identity matrix of the appropriate size when applied to multiorbital sublattices. Similarly, if o::SMatrix it will be truncated or padded to the appropriate size.\n\nonsite(model::TightbindingModel; kw...)\n\nReturn a TightbindingModel with only the onsite terms of model. Any non-missing kw is applied to all such terms.\n\nKeyword arguments\n\nOnly sites at position r in sublattice with name s::NameType will be selected if region(r) && s in sublats is true. Any missing region or sublat will not be used to constraint the selection.\n\nThe keyword sublats allows the following formats:\n\nsublats = :A           # Onsite on sublat :A only\nsublats = (:A,)        # Same as above\nsublats = (:A, :B)     # Onsite on sublat :A and :B\n\nCombining models\n\nOnsiteTerms and HoppingTerms created with onsite or hopping can added or substracted together or be multiplied by scalars to build more complicated TightbindingModels, e.g. onsite(1) - 3 * hopping(2)\n\nExamples\n\njulia> model = onsite(1, sublats = (:A,:B)) - 2 * hopping(2, sublats = :A=>:A)\nTightbindingModel{2}: model with 2 terms\n  OnsiteTerm{Int64}:\n    Sublattices      : (:A, :B)\n    Coefficient      : 1\n  HoppingTerm{Int64}:\n    Sublattice pairs : (:A => :A,)\n    dn cell distance : any\n    Hopping range    : 1.0\n    Coefficient      : -2\n\njulia> newmodel = onsite(model; sublats = :A) + hopping(model)\nTightbindingModel{2}: model with 2 terms\n  OnsiteTerm{Int64}:\n    Sublattices      : (:A,)\n    Coefficient      : 1\n  HoppingTerm{Int64}:\n    Sublattice pairs : (:A => :A,)\n    dn cell distance : any\n    Hopping range    : 1.0\n    Coefficient      : -2\n\njulia> LatticePresets.honeycomb() |> hamiltonian(onsite(r->@SMatrix[1 2; 3 4]), orbitals = Val(2))\nHamiltonian{<:Lattice} : Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 1 (SparseMatrixCSC, sparse)\n  Harmonic size    : 2 × 2\n  Orbitals         : ((:a, :a), (:a, :a))\n  Element type     : 2 × 2 blocks (Complex{Float64})\n  Onsites          : 2\n  Hoppings         : 0\n  Coordination     : 0.0\n\nSee also:\n\n`hopping`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.optimize!-Union{Tuple{Quantica.Hamiltonian{#s35,L,M,A,H,O} where O<:Tuple{Vararg{Tuple{Vararg{Symbol,N} where N},N} where N} where H<:Quantica.HamiltonianHarmonic{L,M,A} where #s35<:Quantica.Lattice}, Tuple{A}, Tuple{M}, Tuple{L}} where A<:SparseMatrixCSC where M where L","page":"Reference","title":"Quantica.optimize!","text":"optimize!(h::Hamiltonian)\n\nPrepare a sparse Hamiltonian h to increase the performance of subsequent calls to bloch(h, ϕs) and bloch!(matrix, h, ϕs) by minimizing memory reshufflings. It also adds missing structural zeros to the diagonal to enable shifts by α*I (for shift-and-invert methods).\n\nNo optimization will be performed on non-sparse Hamiltonians, or those defined on Superlattices, for which Bloch Hamiltonians are lazily evaluated.\n\nNote that when calling similarmatrix(h) on a sparse h, optimize! is called first.\n\nSee also:\n\n`bloch`, `bloch!`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.parameters-Tuple{Quantica.ParametricHamiltonian}","page":"Reference","title":"Quantica.parameters","text":"parameters(ph::ParametricHamiltonian)\n\nReturn the names of the parameter that ph depends on\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.parameters-Tuple{Vararg{Quantica.ElementModifier,N} where N}","page":"Reference","title":"Quantica.parameters","text":"parameters(p::ElementModifier...)\n\nReturn the parameter names for one or several  ElementModifier created with @onsite! or @hopping!\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.parametric-Tuple{Quantica.Hamiltonian,Vararg{Quantica.ElementModifier,N} where N}","page":"Reference","title":"Quantica.parametric","text":"parametric(h::Hamiltonian, modifiers::ElementModifier...)\n\nBuilds a ParametricHamiltonian that can be used to efficiently apply modifiers to h. modifiers can be any number of @onsite!(args -> body; kw...) and @hopping!(args -> body; kw...) transformations, each with a set of parameters ps given as keyword arguments of functions f = (...; ps...) -> body. The resulting ph::ParamtricHamiltonian can be used to produced the modified Hamiltonian simply by calling it with those same parameters as keyword arguments.\n\nNote 1: for sparse h, parametric only modifies existing onsites and hoppings in h, so be sure to add zero onsites and/or hoppings to h if they are originally not present but you need to apply modifiers to them.\n\nNote 2: optimize!(h) is called prior to building the parametric Hamiltonian. This can lead to extra zero onsites and hoppings being stored in sparse hs.\n\nh |> parametric(modifiers::ElementModifier...)\n\nFunction form of parametric, equivalent to parametric(h, modifiers...).\n\nExamples\n\njulia> ph = LatticePresets.honeycomb() |> hamiltonian(onsite(0) + hopping(1, range = 1/√3)) |>\n       unitcell(10) |> parametric(@onsite!((o; μ) -> o - μ))\nParametricHamiltonian{<:Lattice} : Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 5 (SparseMatrixCSC, sparse)\n  Harmonic size    : 200 × 200\n  Orbitals         : ((:a,), (:a,))\n  Element type     : scalar (Complex{Float64})\n  Onsites          : 0\n  Hoppings         : 600\n  Coordination     : 3.0\n  Parameters       : (:μ,)\n\njulia> ph(μ = 2)\nHamiltonian{<:Lattice} : Hamiltonian on a 2D Lattice in 2D space\n  Bloch harmonics  : 5 (SparseMatrixCSC, sparse)\n  Harmonic size    : 200 × 200\n  Orbitals         : ((:a,), (:a,))\n  Element type     : scalar (Complex{Float64})\n  Onsites          : 200\n  Hoppings         : 600\n  Coordination     : 3.0\n\nSee also\n\n`@onsite!`, `@hopping!`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.permutations-Tuple{Any,Integer}","page":"Reference","title":"Quantica.permutations","text":"permutations(a, t)\n\nGenerate all size t permutations of an indexable object a.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.permutations-Tuple{Any}","page":"Reference","title":"Quantica.permutations","text":"permutations(a)\n\nGenerate all permutations of an indexable object a in lexicographic order. Because the number of permutations can be very large, this function returns an iterator object. Use collect(permutations(a)) to get an array of all permutations.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.similarmatrix-Union{Tuple{Any}, Tuple{A´}, Tuple{Any,Type{A´}}} where A´<:(AbstractArray{T,2} where T)","page":"Reference","title":"Quantica.similarmatrix","text":"similarmatrix(h::Hamiltonian)\n\nCreate an uninitialized matrix of the same type and size    of the Hamiltonian's matrix, calling optimize!(h) first to produce an optimal work matrix in the sparse case.\n\nsimilarmatrix(h::Hamiltonian, T::Type{<:AbstractMatrix})\n\nSpecifies the desired type T of the uninitialized matrix.\n\nsimilarmatrix(h::Hamiltonian, method::AbstractDiagonalizeMethod)\n\nAdapts the type of the matrix (e.g. dense/sparse) to the specified method\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.sites-Tuple{Quantica.AbstractLattice}","page":"Reference","title":"Quantica.sites","text":"sites(lat[, sublat::Int])\n\nExtract the positions of all sites in a lattice, or in a specific sublattice\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.spectrum-Tuple{Any}","page":"Reference","title":"Quantica.spectrum","text":"spectrum(h; method = defaultmethod(h), transform = missing)\n\nCompute the spectrum of a 0D Hamiltonian h (or alternatively of the bounded unit cell of a finite dimensional h) using one of the following methods\n\nmethod                    diagonalization function\n--------------------------------------------------------------\nLinearAlgebraPackage()     LinearAlgebra.eigen!\nArpackPackage()            Arpack.eigs (must be `using Arpack`)\n\nThe option transform = ε -> f(ε) allows to transform eigenvalues by f in the returned spectrum (useful for performing shifts or other postprocessing).\n\nThe energies and eigenstates in the resulting s::Spectrum object can be accessed with energies(s) and states(s)\n\nSee also\n\n`energies`, `states`, `bandstructure`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.states-Tuple{Quantica.Bandstructure,Any}","page":"Reference","title":"Quantica.states","text":"states(bs::Bandstructure, i)\n\nReturn the states of each vertex of the i-th band in bs, in the form of a Matrix of size (nψ, nk), where nψ is the length of each state vector, and nk the number of vertices.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.states-Tuple{Quantica.Spectrum}","page":"Reference","title":"Quantica.states","text":"states(s::Spectrum)\n\nReturn the states of s as the columns of a Matrix\n\nSee also\n\n`spectrum`, `energies`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.sublat-Tuple{Array{#s36,1} where #s36<:(StaticArrays.SArray{Tuple{S},T,1,S} where T where S)}","page":"Reference","title":"Quantica.sublat","text":"sublat(sites...; name::Symbol)\nsublat(sites::Vector{<:SVector}; name::Symbol)\n\nCreate a Sublat{E,T,D} that adds a sublattice, of name name, with sites at positions sites in E dimensional space. Sites can be entered as tuples or SVectors.\n\nExamples\n\njulia> sublat((0.0, 0), (1, 1), (1, -1), name = :A)\nSublat{2,Float64} : sublattice of Float64-typed sites in 2D space\n  Sites    : 3\n  Name     : :A\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.supercell-Tuple{Vararg{Union{Integer, Tuple, StaticArrays.SArray{Tuple{S},T,1,S} where T where S, StaticArrays.SArray{Tuple{S1,S2},T,2,L} where L where T where S2 where S1},N} where N}","page":"Reference","title":"Quantica.supercell","text":"supercell(lat::AbstractLattice{E,L}, v::NTuple{L,Integer}...; region = missing, seed = missing)\nsupercell(lat::AbstractLattice{E,L}, sc::SMatrix{L,L´,Int}; region = missing, seed = missing)\n\nGenerates a Superlattice from an L-dimensional lattice lat with Bravais vectors br´= br * sc, where sc::SMatrix{L,L´,Int} is the integer supercell matrix with the L´ vectors vs as columns. If no v are given, the superlattice will be bounded. If lat has semibounded axes, these cannot be mixed with any other axes (they can only be removed, kept intact or scaled by a factor, see below).\n\nOnly sites at position r such that region(r) == true will be included in the supercell. The search for included sites will start from point seed::Union{Tuple,SVector}, or the origin if missing. If region is missing, a Bravais unit cell perpendicular to the v axes will be selected for the L-L´ non-periodic directions.\n\nsupercell(lattice::AbstractLattice{E,L}, factor::Integer; kw...)\n\nCalls supercell with a uniformly scaled sc = SMatrix{L,L}(factor * I)\n\nsupercell(lattice::AbstractLattice, factors::Integer...; kw...)\n\nCalls supercell with different scaling along each Bravais vector (diagonal supercell with factors along the diagonal)\n\nlat |> supercell(v...; kw...)\n\nFunctional syntax, equivalent to `supercell(lat, v...; kw...)\n\nsupercell(h::Hamiltonian, v...; kw...)\n\nPromotes the Lattice of h to a Superlattice without changing the Hamiltonian itself, which always refers to the unitcell of the lattice.\n\nExamples\n\njulia> supercell(LatticePresets.honeycomb(), region = RegionPresets.circle(300))\nSuperlattice{2,2,Float64,0} : 2D lattice in 2D space, filling a 0D supercell\n  Bravais vectors : ((0.5, 0.866025), (-0.5, 0.866025))\n  Sublattices     : 2\n    Names         : (:A, :B)\n    Sites         : (1, 1) --> 2 total per unit cell\n  Supercell{2,0} for 0D superlattice of the base 2D lattice\n    Supervectors  : ()\n    Supersites    : 652966\n\njulia> supercell(LatticePresets.triangular(), (1,1), (1, -1))\nSuperlattice{2,2,Float64,2} : 2D lattice in 2D space, filling a 2D supercell\n  Bravais vectors : ((0.5, 0.866025), (-0.5, 0.866025))\n  Sublattices     : 1\n    Names         : (:A)\n    Sites         : (1) --> 1 total per unit cell\n  Supercell{2,2} for 2D superlattice of the base 2D lattice\n    Supervectors  : ((1, 1), (1, -1))\n    Supersites    : 2\n\njulia> LatticePresets.square() |> supercell(3)\nSuperlattice{2,2,Float64,2} : 2D lattice in 2D space, filling a 2D supercell\n  Bravais vectors : ((1.0, 0.0), (0.0, 1.0))\n  Sublattices     : 1\n    Names         : (:A)\n    Sites         : (1) --> 1 total per unit cell\n  Supercell{2,2} for 2D superlattice of the base 2D lattice\n    Supervectors  : ((3, 0), (0, 3))\n    Supersites    : 9\n\nSee also:\n\n`unitcell`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.transform!-Tuple{Any,Quantica.Bandstructure}","page":"Reference","title":"Quantica.transform!","text":"transform!(f::Function, b::Bandstructure)\n\nTransform the energies of all bands in b by applying f to them in place.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.transform!-Tuple{Any,Quantica.Hamiltonian}","page":"Reference","title":"Quantica.transform!","text":"transform!(f::Function, h::Hamiltonian)\n\nTransform the site positions of the Hamiltonian's lattice in place without modifying the Hamiltonian harmonics.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.transform!-Tuple{Any,Quantica.Spectrum}","page":"Reference","title":"Quantica.transform!","text":"transform!(f::Function, s::Spectrum)\n\nTransform the energies of s by applying f to them in place.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.transform!-Tuple{Function,Quantica.Lattice}","page":"Reference","title":"Quantica.transform!","text":"transform!(f::Function, lat::Lattice)\n\nTransform the site positions of lat by applying f to them in place.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.unitcell-Tuple{Vararg{Union{Integer, Tuple, StaticArrays.SArray{Tuple{S},T,1,S} where T where S, StaticArrays.SArray{Tuple{S1,S2},T,2,L} where L where T where S2 where S1},N} where N}","page":"Reference","title":"Quantica.unitcell","text":"unitcell(lat::Lattice{E,L}, v::NTuple{L,Integer}...; region = missing, seed = missing)\nunitcell(lat::Lattice{E,L}, uc::SMatrix{L,L´,Int}; region = missing, seed = missing)\n\nGenerates a Lattice from an L-dimensional lattice lat and a larger unit cell, such that its Bravais vectors are br´= br * uc. Here uc::SMatrix{L,L´,Int} is the integer unitcell matrix, with the L´ vectors vs as columns. If no v are given, the new lattice will be bounded.\n\nOnly sites at position r such that region(r) == true will be included in the new unitcell. The search for included sites will start from point seed::Union{Tuple,SVector}, or the origin if missing. If region is missing, a Bravais unitcell perpendicular to the v axes will be selected for the L-L´ non-periodic directions.\n\nunitcell(lattice::Lattice{E,L}, factor::Integer; kw...)\n\nCalls unitcell with a uniformly scaled uc = SMatrix{L,L}(factor * I)\n\nunitcell(lattice::Lattice{E,L}, factors::Integer...; kw...)\n\nCalls unitcell with different scaling along each Bravais vector (diagonal supercell with factors along the diagonal)\n\nunitcell(slat::Superlattice)\n\nConvert Superlattice slat into a lattice with its unit cell matching slat's supercell.\n\nunitcell(h::Hamiltonian, v...; modifiers = (), kw...)\n\nTransforms the Lattice of h to have a larger unitcell, while expanding the Hamiltonian accordingly. The modifiers (a tuple of ElementModifiers, either @onsite! or @hopping! with no free parameters) will be applied to onsite and hoppings as the hamiltonian is expanded. See @onsite! and @hopping! for details\n\nNote: for performance reasons, in sparse hamiltonians only the stored onsites and hoppings will be transformed by ElementModifiers, so you might want to add zero onsites or hoppings when building h to have a modifier applied to them later. Note also that additional onsites and hoppings may be stored when calling optimize! or bloch/bloch! on h for the first time.\n\nlat_or_h |> unitcell(v...; kw...)\n\nFunctional syntax, equivalent to `unitcell(latorh, v...; kw...)\n\nExamples\n\njulia> unitcell(LatticePresets.honeycomb(), region = RegionPresets.circle(300))\nLattice{2,0,Float64} : 0D lattice in 2D space\n  Bravais vectors : ()\n  Sublattices     : 2\n    Names         : (:A, :B)\n    Sites         : (326483, 326483) --> 652966 total per unit cell\n\njulia> unitcell(LatticePresets.triangular(), (1,1), (1, -1))\nLattice{2,2,Float64} : 2D lattice in 2D space\n  Bravais vectors : ((0.0, 1.732051), (1.0, 0.0))\n  Sublattices     : 1\n    Names         : (:A)\n    Sites         : (2) --> 2 total per unit cell\n\njulia> LatticePresets.square() |> unitcell(3)\nLattice{2,2,Float64} : 2D lattice in 2D space\n  Bravais vectors : ((3.0, 0.0), (0.0, 3.0))\n  Sublattices     : 1\n    Names         : (:A)\n    Sites         : (9) --> 9 total per unit cell\n\njulia> supercell(LatticePresets.square(), 3) |> unitcell\nLattice{2,2,Float64} : 2D lattice in 2D space\n  Bravais vectors : ((3.0, 0.0), (0.0, 3.0))\n  Sublattices     : 1\n    Names         : (:A)\n    Sites         : (9) --> 9 total per unit cell\n\nSee also:\n\n`supercell`\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.vertices-Tuple{Quantica.Bandstructure,Any}","page":"Reference","title":"Quantica.vertices","text":"vertices(bs::Bandstructure, i)\n\nReturn the vertices (k..., ϵ) of the i-th band in bs, in the form of a Vector{SVector{L+1}}, where L is the lattice dimension.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.wrap-Union{Tuple{L}, Tuple{Quantica.Hamiltonian{#s36,L,M,A,H,O} where O<:Tuple{Vararg{Tuple{Vararg{Symbol,N} where N},N} where N} where H<:Quantica.HamiltonianHarmonic{L,M,A} where A<:(AbstractArray{T,2} where T) where M where #s36<:Quantica.Lattice,Any}} where L","page":"Reference","title":"Quantica.wrap","text":"wrap(h::Hamiltonian, axis::Int; factor = 1)\n\nBuild a new Hamiltonian wherein the Bravais axis is wrapped into a loop. If a factor is given, the wrapped hoppings will be multiplied by said factor. This is useful to represent a flux Φ through the loop, if factor = exp(im * 2π * Φ/Φ₀).\n\nh |> wrap(axis; kw...)\n\nFunctional form equivalent to wrap(h, axis; kw...).\n\nExamples\n\njulia> LatticePresets.honeycomb() |> hamiltonian(hopping(1, range = 1/√3)) |>\n       unitcell((1,-1), (10, 10)) |> wrap(2)\nHamiltonian{<:Lattice} : Hamiltonian on a 1D Lattice in 2D space\n  Bloch harmonics  : 3 (SparseMatrixCSC, sparse)\n  Harmonic size    : 40 × 40\n  Orbitals         : ((:a,), (:a,))\n  Element type     : scalar (Complex{Float64})\n  Onsites          : 0\n  Hoppings         : 120\n  Coordination     : 3.0\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantica.@hopping!-Tuple{Any,Any}","page":"Reference","title":"Quantica.@hopping!","text":"@hopping!(args -> body; kw...)\n\nCreate an ElementModifier, to be used with parametric, that applies f = args -> body to hoppings energies specified by kw (see hopping for details on possible kws). The form of args -> body may be (t; params...) -> ... or (t, r, dr; params...) -> ... if the modification is position (r, dr) dependent. Keyword arguments params are optional, and include any parameters that body depends on that the user may want to tune.\n\nSee also:\n\n`@onsite!`, `parametric`\n\n\n\n\n\n","category":"macro"},{"location":"reference/#Quantica.@onsite!-Tuple{Any,Any}","page":"Reference","title":"Quantica.@onsite!","text":"@onsite!(args -> body; kw...)\n\nCreate an ElementModifier, to be used with parametric, that applies f = args -> body to onsite energies specified by kw (see onsite for details  on possible kws). The form of args -> body may be (o; params...) -> ... or (o, r; params...) -> ... if the modification is position (r) dependent. Keyword arguments params are optional, and include any parameters that body depends on that the user may want to tune.\n\nSee also:\n\n`@hopping!`, `parametric`\n\n\n\n\n\n","category":"macro"},{"location":"#Quantica.jl","page":"Home","title":"Quantica.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Quantica.jl is a Julia package for building generic tight-binding models and computing various spectral and transport properties.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Important information\nThis package supersedes Elsa.jl, which will soon be deprecated.","category":"page"},{"location":"#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"tutorial.md\",\n    \"examples.md\",\n    \"reference.md\",\n]\nDepth = 1","category":"page"},{"location":"#Current-functionality","page":"Home","title":"Current functionality","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Build arbitrary lattices (periodic or bounded in any dimension and with any unit cell)\nDefine generic model Hamiltonians by applying a model onto a lattice\nUse models with arbitrary orbital structure, spatial dependence and coordination (e.g. normal/superconducting, spin-orbit coupling, etc.)\nDefine parametric Hamiltonians that efficiently implement external parameters dependencies\nEfficiently compute the Bloch Hamiltonian matrix at arbitrary wave vector\nCompute the band structure or spectrum of a Hamiltonian, using advanced meshing and co-diagonalization techniques to resolve degeneracies and extract subbands\nUse Order-N Kernel polynomial methods to compute spectral and transport properties efficiently","category":"page"},{"location":"","page":"Home","title":"Home","text":"tip: Funding\nThis work has been partly funded by the Spanish Ministry of Economy and Competitiveness under Grant Nos. FIS2015-65706-P, PCI2018-093026, and the CSIC Intramural Project 201760I086.","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"}]
}
